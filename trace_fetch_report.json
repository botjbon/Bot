{
  "generatedAt": "2025-09-10T06:24:16.184Z",
  "findings": [
    {
      "file": "monitor.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 2,
          "snippet": "const ff = require('./src/fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        }
      ]
    },
    {
      "file": "monitor.ts",
      "func": "(async function main() {",
      "hits": [
        {
          "line": 32,
          "snippet": "const latest = await ff.fetchLatest5FromAllSources(200);",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 33,
          "snippet": "const candidates = Array.from(new Set([...(latest.heliusEvents || []), ...(latest.dexTop || []), ...(latest.heliusHistory || [])]));",
          "pattern": "rpc_helius"
        },
        {
          "line": 33,
          "snippet": "const candidates = Array.from(new Set([...(latest.heliusEvents || []), ...(latest.dexTop || []), ...(latest.heliusHistory || [])]));",
          "pattern": "rpc_helius"
        },
        {
          "line": 33,
          "snippet": "const candidates = Array.from(new Set([...(latest.heliusEvents || []), ...(latest.dexTop || []), ...(latest.heliusHistory || [])]));",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 34,
          "snippet": "const allTokens = await utils.fetchDexScreenerTokens('solana', { limit: '500' }).catch(() => []);",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "scripts/enrich_worker.js",
      "func": "<top>",
      "hits": [
        {
          "line": 5,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 5,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 13,
          "snippet": "const _HELIUS_KEYS = (process.env.HELIUS_API_KEYS || process.env.HELIUS_API_KEY || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 13,
          "snippet": "const _HELIUS_KEYS = (process.env.HELIUS_API_KEYS || process.env.HELIUS_API_KEY || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 13,
          "snippet": "const _HELIUS_KEYS = (process.env.HELIUS_API_KEYS || process.env.HELIUS_API_KEY || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 14,
          "snippet": "const HELIUS_RPC_URLS = (process.env.HELIUS_RPC_URLS || process.env.HELIUS_RPC_URL || process.env.HELIUS_RPC || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 14,
          "snippet": "const HELIUS_RPC_URLS = (process.env.HELIUS_RPC_URLS || process.env.HELIUS_RPC_URL || process.env.HELIUS_RPC || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 14,
          "snippet": "const HELIUS_RPC_URLS = (process.env.HELIUS_RPC_URLS || process.env.HELIUS_RPC_URL || process.env.HELIUS_RPC || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 14,
          "snippet": "const HELIUS_RPC_URLS = (process.env.HELIUS_RPC_URLS || process.env.HELIUS_RPC_URL || process.env.HELIUS_RPC || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 15,
          "snippet": "if(_HELIUS_KEYS.length===0){ const k = process.env.HELIUS_API_KEY || ''; if(k) _HELIUS_KEYS.push(k); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 15,
          "snippet": "if(_HELIUS_KEYS.length===0){ const k = process.env.HELIUS_API_KEY || ''; if(k) _HELIUS_KEYS.push(k); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 15,
          "snippet": "if(_HELIUS_KEYS.length===0){ const k = process.env.HELIUS_API_KEY || ''; if(k) _HELIUS_KEYS.push(k); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 16,
          "snippet": "if(HELIUS_RPC_URLS.length===0){ HELIUS_RPC_URLS.push('https://mainnet.helius-rpc.com/'); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 16,
          "snippet": "if(HELIUS_RPC_URLS.length===0){ HELIUS_RPC_URLS.push('https://mainnet.helius-rpc.com/'); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 16,
          "snippet": "if(HELIUS_RPC_URLS.length===0){ HELIUS_RPC_URLS.push('https://mainnet.helius-rpc.com/'); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 17,
          "snippet": "let heliusCallCounter = 0;",
          "pattern": "rpc_helius"
        },
        {
          "line": 20,
          "snippet": "if(!ALLOW_ENRICH){ console.error('[COLLECTOR-GUARD] enrich_worker: Helius RPCs disabled (FORCE_ENRICH not set). To enable set FORCE_ENRICH=true in the environment.'); }",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/enrich_worker.js",
      "func": "async function heliusRpc(method, params){",
      "hits": [
        {
          "line": 31,
          "snippet": "const res = await axios.post(url, { jsonrpc:'2.0', id:1, method, params }, { headers: hdrs, timeout:15000 });",
          "pattern": "axios"
        },
        {
          "line": 22,
          "snippet": "async function heliusRpc(method, params){",
          "pattern": "rpc_helius"
        },
        {
          "line": 26,
          "snippet": "const keyIdx = heliusCallCounter % Math.max(1, _HELIUS_KEYS.length);",
          "pattern": "rpc_helius"
        },
        {
          "line": 26,
          "snippet": "const keyIdx = heliusCallCounter % Math.max(1, _HELIUS_KEYS.length);",
          "pattern": "rpc_helius"
        },
        {
          "line": 27,
          "snippet": "const urlIdx = heliusCallCounter % Math.max(1, HELIUS_RPC_URLS.length);",
          "pattern": "rpc_helius"
        },
        {
          "line": 27,
          "snippet": "const urlIdx = heliusCallCounter % Math.max(1, HELIUS_RPC_URLS.length);",
          "pattern": "rpc_helius"
        },
        {
          "line": 28,
          "snippet": "heliusCallCounter = (heliusCallCounter + 1) >>> 0;",
          "pattern": "rpc_helius"
        },
        {
          "line": 28,
          "snippet": "heliusCallCounter = (heliusCallCounter + 1) >>> 0;",
          "pattern": "rpc_helius"
        },
        {
          "line": 29,
          "snippet": "const url = HELIUS_RPC_URLS[urlIdx];",
          "pattern": "rpc_helius"
        },
        {
          "line": 30,
          "snippet": "const hdrs = Object.assign({ 'Content-Type': 'application/json' }, _HELIUS_KEYS[keyIdx] ? { 'x-api-key': _HELIUS_KEYS[keyIdx] } : {});",
          "pattern": "rpc_helius"
        },
        {
          "line": 30,
          "snippet": "const hdrs = Object.assign({ 'Content-Type': 'application/json' }, _HELIUS_KEYS[keyIdx] ? { 'x-api-key': _HELIUS_KEYS[keyIdx] } : {});",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/enrich_worker.js",
      "func": "async function processOne(file){",
      "hits": [
        {
          "line": 46,
          "snippet": "const sigs = await heliusRpc('getSignaturesForAddress', [m, { limit: 1 }]);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "<top>",
      "hits": [
        {
          "line": 5,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 5,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 1008,
          "snippet": "try { const t = require('../src/utils/trace'); t.traceFlow('collector:collectFreshMints:finished',{ collectedCount: collected.length, sample: collected.slice(0,3).map(i=> (i && (i.mint||i.address||i.tokenAddress)) ) }); } catch(e){}",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1019,
          "snippet": "module.exports.collectFreshMints = collectFreshMints;",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1019,
          "snippet": "module.exports.collectFreshMints = collectFreshMints;",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1061,
          "snippet": "const collectorFn = (module.exports && module.exports.collectFreshMints) ? module.exports.collectFreshMints : collectFreshMints;",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1061,
          "snippet": "const collectorFn = (module.exports && module.exports.collectFreshMints) ? module.exports.collectFreshMints : collectFreshMints;",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1061,
          "snippet": "const collectorFn = (module.exports && module.exports.collectFreshMints) ? module.exports.collectFreshMints : collectFreshMints;",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1132,
          "snippet": "module.exports.collectFreshMintsPerUser = collectFreshMintsPerUser;",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1132,
          "snippet": "module.exports.collectFreshMintsPerUser = collectFreshMintsPerUser;",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 7,
          "snippet": "// Helius RPC configuration: support rotating API keys and RPC URLs to reduce pressure",
          "pattern": "rpc_helius"
        },
        {
          "line": 8,
          "snippet": "// Provide comma-separated lists in env: HELIUS_API_KEYS and HELIUS_RPC_URLS",
          "pattern": "rpc_helius"
        },
        {
          "line": 8,
          "snippet": "// Provide comma-separated lists in env: HELIUS_API_KEYS and HELIUS_RPC_URLS",
          "pattern": "rpc_helius"
        },
        {
          "line": 9,
          "snippet": "const _HELIUS_KEYS = (process.env.HELIUS_API_KEYS || process.env.HELIUS_API_KEY || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 9,
          "snippet": "const _HELIUS_KEYS = (process.env.HELIUS_API_KEYS || process.env.HELIUS_API_KEY || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 9,
          "snippet": "const _HELIUS_KEYS = (process.env.HELIUS_API_KEYS || process.env.HELIUS_API_KEY || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 10,
          "snippet": "const HELIUS_RPC_URLS = (process.env.HELIUS_RPC_URLS || process.env.HELIUS_RPC_URL || process.env.HELIUS_RPC || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 10,
          "snippet": "const HELIUS_RPC_URLS = (process.env.HELIUS_RPC_URLS || process.env.HELIUS_RPC_URL || process.env.HELIUS_RPC || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 10,
          "snippet": "const HELIUS_RPC_URLS = (process.env.HELIUS_RPC_URLS || process.env.HELIUS_RPC_URL || process.env.HELIUS_RPC || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 10,
          "snippet": "const HELIUS_RPC_URLS = (process.env.HELIUS_RPC_URLS || process.env.HELIUS_RPC_URL || process.env.HELIUS_RPC || '').toString().split(',').map(s=>s.trim()).filter(Boolean);",
          "pattern": "rpc_helius"
        },
        {
          "line": 12,
          "snippet": "if(_HELIUS_KEYS.length===0){ const k = process.env.HELIUS_API_KEY || ''; if(k) _HELIUS_KEYS.push(k); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 12,
          "snippet": "if(_HELIUS_KEYS.length===0){ const k = process.env.HELIUS_API_KEY || ''; if(k) _HELIUS_KEYS.push(k); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 12,
          "snippet": "if(_HELIUS_KEYS.length===0){ const k = process.env.HELIUS_API_KEY || ''; if(k) _HELIUS_KEYS.push(k); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 13,
          "snippet": "if(HELIUS_RPC_URLS.length===0){ HELIUS_RPC_URLS.push('https://mainnet.helius-rpc.com/'); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 13,
          "snippet": "if(HELIUS_RPC_URLS.length===0){ HELIUS_RPC_URLS.push('https://mainnet.helius-rpc.com/'); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 13,
          "snippet": "if(HELIUS_RPC_URLS.length===0){ HELIUS_RPC_URLS.push('https://mainnet.helius-rpc.com/'); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 15,
          "snippet": "let heliusCallCounter = 0;",
          "pattern": "rpc_helius"
        },
        {
          "line": 501,
          "snippet": "const sigs = await heliusRpc('getSignaturesForAddress', [p, { limit: SIG_BATCH_LIMIT }]);",
          "pattern": "rpc_helius"
        },
        {
          "line": 117,
          "snippet": "let _redisClient = null;",
          "pattern": "redis"
        },
        {
          "line": 120,
          "snippet": "const { createClient } = require('redis');",
          "pattern": "redis"
        },
        {
          "line": 121,
          "snippet": "_redisClient = createClient({ url: REDIS_URL });",
          "pattern": "redis"
        },
        {
          "line": 121,
          "snippet": "_redisClient = createClient({ url: REDIS_URL });",
          "pattern": "redis"
        },
        {
          "line": 122,
          "snippet": "_redisClient.on && _redisClient.on('error', ()=>{});",
          "pattern": "redis"
        },
        {
          "line": 122,
          "snippet": "_redisClient.on && _redisClient.on('error', ()=>{});",
          "pattern": "redis"
        },
        {
          "line": 124,
          "snippet": "_redisClient.connect().catch(()=>{});",
          "pattern": "redis"
        },
        {
          "line": 125,
          "snippet": "}catch(e){ _redisClient = null; }",
          "pattern": "redis"
        },
        {
          "line": 805,
          "snippet": "const { createClient } = require('redis');",
          "pattern": "redis"
        },
        {
          "line": 806,
          "snippet": "const rc = createClient({ url: REDIS_URL });",
          "pattern": "redis"
        },
        {
          "line": 661,
          "snippet": "try{ notifier.emit('programEvent', globalEvent); }catch(e){}",
          "pattern": "ws_listener"
        },
        {
          "line": 799,
          "snippet": "try{ notifier.emit('notification', payload); }catch(e){}",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "async function heliusRpc(method, params){",
      "hits": [
        {
          "line": 221,
          "snippet": "const res = await axios.post(url, { jsonrpc:'2.0', id:1, method, params }, { headers: hdrs, timeout: heliusTimeout });",
          "pattern": "axios"
        },
        {
          "line": 207,
          "snippet": "async function heliusRpc(method, params){",
          "pattern": "rpc_helius"
        },
        {
          "line": 209,
          "snippet": "const maxRetries = Number(process.env.HELIUS_RPC_MAX_RETRIES || 2);",
          "pattern": "rpc_helius"
        },
        {
          "line": 214,
          "snippet": "const keyIdx = heliusCallCounter % Math.max(1, _HELIUS_KEYS.length);",
          "pattern": "rpc_helius"
        },
        {
          "line": 214,
          "snippet": "const keyIdx = heliusCallCounter % Math.max(1, _HELIUS_KEYS.length);",
          "pattern": "rpc_helius"
        },
        {
          "line": 215,
          "snippet": "const urlIdx = heliusCallCounter % Math.max(1, HELIUS_RPC_URLS.length);",
          "pattern": "rpc_helius"
        },
        {
          "line": 215,
          "snippet": "const urlIdx = heliusCallCounter % Math.max(1, HELIUS_RPC_URLS.length);",
          "pattern": "rpc_helius"
        },
        {
          "line": 216,
          "snippet": "heliusCallCounter = (heliusCallCounter + 1) >>> 0;",
          "pattern": "rpc_helius"
        },
        {
          "line": 216,
          "snippet": "heliusCallCounter = (heliusCallCounter + 1) >>> 0;",
          "pattern": "rpc_helius"
        },
        {
          "line": 217,
          "snippet": "const url = HELIUS_RPC_URLS[urlIdx];",
          "pattern": "rpc_helius"
        },
        {
          "line": 218,
          "snippet": "const hdrs = Object.assign({ 'Content-Type': 'application/json' }, _HELIUS_KEYS[keyIdx] ? { 'x-api-key': _HELIUS_KEYS[keyIdx] } : {});",
          "pattern": "rpc_helius"
        },
        {
          "line": 218,
          "snippet": "const hdrs = Object.assign({ 'Content-Type': 'application/json' }, _HELIUS_KEYS[keyIdx] ? { 'x-api-key': _HELIUS_KEYS[keyIdx] } : {});",
          "pattern": "rpc_helius"
        },
        {
          "line": 219,
          "snippet": "// make helius timeout configurable (default 5000ms) to favor low-latency responses",
          "pattern": "rpc_helius"
        },
        {
          "line": 220,
          "snippet": "const heliusTimeout = Number(process.env.HELIUS_RPC_TIMEOUT_MS) || 5000;",
          "pattern": "rpc_helius"
        },
        {
          "line": 220,
          "snippet": "const heliusTimeout = Number(process.env.HELIUS_RPC_TIMEOUT_MS) || 5000;",
          "pattern": "rpc_helius"
        },
        {
          "line": 221,
          "snippet": "const res = await axios.post(url, { jsonrpc:'2.0', id:1, method, params }, { headers: hdrs, timeout: heliusTimeout });",
          "pattern": "rpc_helius"
        },
        {
          "line": 231,
          "snippet": "const base = Number(process.env.HELIUS_RPC_RETRY_BASE_MS) || 150;",
          "pattern": "rpc_helius"
        },
        {
          "line": 243,
          "snippet": "// Common helius getTransaction options",
          "pattern": "rpc_helius"
        },
        {
          "line": 244,
          "snippet": "const HELIUS_TX_OPTS = { encoding: 'jsonParsed', maxSupportedTransactionVersion: 0 };",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "async function collectFreshMints({ maxCollect = 3, timeoutMs = (Number(process.env.COLLECT_TIMEOUT_MS) || Math.max(20000, PER_PROGRAM_DURATION_MS * (PROGRAMS.length || 1) + 5000)), maxAgeSec = undefined, strictOverride = false, ageOnly = false, onlyPrintExplicit = undefined } = {}){",
      "hits": [
        {
          "line": 872,
          "snippet": "async function collectFreshMints({ maxCollect = 3, timeoutMs = (Number(process.env.COLLECT_TIMEOUT_MS) || Math.max(20000, PER_PROGRAM_DURATION_MS * (PROGRAMS.length || 1) + 5000)), maxAgeSec = undefined, strictOverride = false, ageOnly = false, onlyPrintExplicit = undefined } = {}){",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 885,
          "snippet": "const sigs = await heliusRpc('getSignaturesForAddress', [p, { limit: SIG_BATCH_LIMIT }]);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "async function collectFreshMintsPerUser(usersObj = {}, { maxCollect = 10, timeoutMs = (Number(process.env.COLLECT_TIMEOUT_MS) || 20000), strictOverride = false, ageOnly = false } = {}){",
      "hits": [
        {
          "line": 1021,
          "snippet": "async function collectFreshMintsPerUser(usersObj = {}, { maxCollect = 10, timeoutMs = (Number(process.env.COLLECT_TIMEOUT_MS) || 20000), strictOverride = false, ageOnly = false } = {}){",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1027,
          "snippet": "try{ if(!MINIMAL_OUTPUT) console.error(`[LISTENER_DEBUG] collectFreshMintsPerUser starting collector for users=${Object.keys(usersObj||{}).length}`); }catch(e){}",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1028,
          "snippet": "try { const t = require('../src/utils/trace'); t.traceFlow('collector:collectFreshMintsPerUser:start',{ userCount: Object.keys(usersObj||{}).length, maxCollect, timeoutMs, strictOverride, ageOnly }); } catch(e){}",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1060,
          "snippet": "// collect an unbiased batch (explicit-only enforced inside collectFreshMints)",
          "pattern": "collector_collectFreshMints"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "function looksLikeUrl(u){ try{ return String(u).toLowerCase().startsWith('http'); }catch(e){ return false; } }",
      "hits": [
        {
          "line": 19,
          "snippet": "const badKeys = _HELIUS_KEYS.filter(looksLikePlaceholderKey);",
          "pattern": "rpc_helius"
        },
        {
          "line": 20,
          "snippet": "const badUrls = HELIUS_RPC_URLS.filter(u => !looksLikeUrl(u));",
          "pattern": "rpc_helius"
        },
        {
          "line": 22,
          "snippet": "console.error('Helius configuration validation failed: please set real API keys and valid RPC URLs via environment variables.');",
          "pattern": "rpc_helius"
        },
        {
          "line": 23,
          "snippet": "if(badKeys.length>0) console.error('  Detected placeholder-ish HELIUS_API_KEYS:', JSON.stringify(_HELIUS_KEYS));",
          "pattern": "rpc_helius"
        },
        {
          "line": 23,
          "snippet": "if(badKeys.length>0) console.error('  Detected placeholder-ish HELIUS_API_KEYS:', JSON.stringify(_HELIUS_KEYS));",
          "pattern": "rpc_helius"
        },
        {
          "line": 24,
          "snippet": "if(badUrls.length>0) console.error('  Detected invalid HELIUS_RPC_URLS:', JSON.stringify(HELIUS_RPC_URLS));",
          "pattern": "rpc_helius"
        },
        {
          "line": 24,
          "snippet": "if(badUrls.length>0) console.error('  Detected invalid HELIUS_RPC_URLS:', JSON.stringify(HELIUS_RPC_URLS));",
          "pattern": "rpc_helius"
        },
        {
          "line": 26,
          "snippet": "console.error('  HELIUS_API_KEYS=\"yourKey1,yourKey2\" HELIUS_RPC_URLS=\"https://mainnet.helius-rpc.com/,https://rpc2.example/\" node scripts/sequential_10s_per_program.js');",
          "pattern": "rpc_helius"
        },
        {
          "line": 26,
          "snippet": "console.error('  HELIUS_API_KEYS=\"yourKey1,yourKey2\" HELIUS_RPC_URLS=\"https://mainnet.helius-rpc.com/,https://rpc2.example/\" node scripts/sequential_10s_per_program.js');",
          "pattern": "rpc_helius"
        },
        {
          "line": 26,
          "snippet": "console.error('  HELIUS_API_KEYS=\"yourKey1,yourKey2\" HELIUS_RPC_URLS=\"https://mainnet.helius-rpc.com/,https://rpc2.example/\" node scripts/sequential_10s_per_program.js');",
          "pattern": "rpc_helius"
        },
        {
          "line": 34,
          "snippet": "const notifier = new EventEmitter();",
          "pattern": "ws_listener"
        },
        {
          "line": 35,
          "snippet": "// export notifier when required as a module",
          "pattern": "ws_listener"
        },
        {
          "line": 36,
          "snippet": "try{ module.exports = module.exports || {}; module.exports.notifier = notifier; }catch(e){}",
          "pattern": "ws_listener"
        },
        {
          "line": 36,
          "snippet": "try{ module.exports = module.exports || {}; module.exports.notifier = notifier; }catch(e){}",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "async function getFirstSignatureCached(mint){",
      "hits": [
        {
          "line": 182,
          "snippet": "const res = await heliusRpc('getSignaturesForAddress', [mint, { limit: 1 }]);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "function sleep(ms){return new Promise(r=>setTimeout(r,ms));}",
      "hits": [
        {
          "line": 205,
          "snippet": "// heliusRpc(method, params, useEnrich=false)",
          "pattern": "rpc_helius"
        },
        {
          "line": 206,
          "snippet": "// when useEnrich=true the call uses the second Helius key / URL for enrichment work",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "function _releaseTxSlot(){",
      "hits": [
        {
          "line": 264,
          "snippet": "// fetchTransaction: uses heliusRpc under the hood but adds concurrency limiting and retries/backoff",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "async function fetchTransaction(sig){",
      "hits": [
        {
          "line": 269,
          "snippet": "const res = await heliusRpc('getTransaction', [sig, HELIUS_TX_OPTS]);",
          "pattern": "rpc_helius"
        },
        {
          "line": 269,
          "snippet": "const res = await heliusRpc('getTransaction', [sig, HELIUS_TX_OPTS]);",
          "pattern": "rpc_helius"
        },
        {
          "line": 270,
          "snippet": "// heliusRpc returns an object with __error on failure",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "async function mintPreviouslySeen(mint, txBlockTime, currentSig){",
      "hits": [
        {
          "line": 389,
          "snippet": "const sigs = await heliusRpc('getSignaturesForAddress', [mint, { limit: MINT_SIG_LIMIT }]);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "scripts/sequential_10s_per_program.js",
      "func": "function publishLatestCollectedSnapshot(){",
      "hits": [
        {
          "line": 129,
          "snippet": "if(!_redisClient) return;",
          "pattern": "redis"
        },
        {
          "line": 134,
          "snippet": "_redisClient.set(key, payload, { EX: ttl }).catch(()=>{});",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "scripts/trace_fetch_paths.js",
      "func": "<top>",
      "hits": [
        {
          "line": 11,
          "snippet": "{ name: 'axios', re: /\\baxios\\b/g },",
          "pattern": "axios"
        },
        {
          "line": 13,
          "snippet": "{ name: 'collector_collectFreshMints', re: /collectFreshMintsPerUser|collectFreshMints\\b/g },",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 13,
          "snippet": "{ name: 'collector_collectFreshMints', re: /collectFreshMintsPerUser|collectFreshMints\\b/g },",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 13,
          "snippet": "{ name: 'collector_collectFreshMints', re: /collectFreshMintsPerUser|collectFreshMints\\b/g },",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 14,
          "snippet": "{ name: 'fastTokenFetcher', re: /fastTokenFetcher|fetchFirstSignatureForMint|fetchLatest5FromAllSources/g },",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 14,
          "snippet": "{ name: 'fastTokenFetcher', re: /fastTokenFetcher|fetchFirstSignatureForMint|fetchLatest5FromAllSources/g },",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 14,
          "snippet": "{ name: 'fastTokenFetcher', re: /fastTokenFetcher|fetchFirstSignatureForMint|fetchLatest5FromAllSources/g },",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 14,
          "snippet": "{ name: 'fastTokenFetcher', re: /fastTokenFetcher|fetchFirstSignatureForMint|fetchLatest5FromAllSources/g },",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 15,
          "snippet": "{ name: 'enrich', re: /enrichTokenTimestamps|officialEnrich|officialEnrich\\b|autoFilterTokensVerbose|autoFilterTokens/g },",
          "pattern": "enrich"
        },
        {
          "line": 15,
          "snippet": "{ name: 'enrich', re: /enrichTokenTimestamps|officialEnrich|officialEnrich\\b|autoFilterTokensVerbose|autoFilterTokens/g },",
          "pattern": "enrich"
        },
        {
          "line": 15,
          "snippet": "{ name: 'enrich', re: /enrichTokenTimestamps|officialEnrich|officialEnrich\\b|autoFilterTokensVerbose|autoFilterTokens/g },",
          "pattern": "enrich"
        },
        {
          "line": 15,
          "snippet": "{ name: 'enrich', re: /enrichTokenTimestamps|officialEnrich|officialEnrich\\b|autoFilterTokensVerbose|autoFilterTokens/g },",
          "pattern": "enrich"
        },
        {
          "line": 15,
          "snippet": "{ name: 'enrich', re: /enrichTokenTimestamps|officialEnrich|officialEnrich\\b|autoFilterTokensVerbose|autoFilterTokens/g },",
          "pattern": "enrich"
        },
        {
          "line": 16,
          "snippet": "{ name: 'rpc_helius', re: /HELIUS|helius|Helius/g },",
          "pattern": "rpc_helius"
        },
        {
          "line": 16,
          "snippet": "{ name: 'rpc_helius', re: /HELIUS|helius|Helius/g },",
          "pattern": "rpc_helius"
        },
        {
          "line": 16,
          "snippet": "{ name: 'rpc_helius', re: /HELIUS|helius|Helius/g },",
          "pattern": "rpc_helius"
        },
        {
          "line": 16,
          "snippet": "{ name: 'rpc_helius', re: /HELIUS|helius|Helius/g },",
          "pattern": "rpc_helius"
        },
        {
          "line": 21,
          "snippet": "{ name: 'ws_listener', re: /WsListener|heliusWsListener|wsListener|notifier/g },",
          "pattern": "rpc_helius"
        },
        {
          "line": 17,
          "snippet": "{ name: 'redis', re: /\\bcreateClient\\(|rc\\.get\\(|rc\\.rPop\\(|redis/g },",
          "pattern": "redis"
        },
        {
          "line": 17,
          "snippet": "{ name: 'redis', re: /\\bcreateClient\\(|rc\\.get\\(|rc\\.rPop\\(|redis/g },",
          "pattern": "redis"
        },
        {
          "line": 18,
          "snippet": "{ name: 'db_mongo', re: /mongoose\\b|MongoClient/g },",
          "pattern": "db_mongo"
        },
        {
          "line": 18,
          "snippet": "{ name: 'db_mongo', re: /mongoose\\b|MongoClient/g },",
          "pattern": "db_mongo"
        },
        {
          "line": 19,
          "snippet": "{ name: 'unified_trade', re: /unifiedBuy|unifiedSell/g },",
          "pattern": "unified_trade"
        },
        {
          "line": 19,
          "snippet": "{ name: 'unified_trade', re: /unifiedBuy|unifiedSell/g },",
          "pattern": "unified_trade"
        },
        {
          "line": 20,
          "snippet": "{ name: 'dextools/dexscreener', re: /dexscreener|DexScreener|dexTop|dexTop/g },",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 20,
          "snippet": "{ name: 'dextools/dexscreener', re: /dexscreener|DexScreener|dexTop|dexTop/g },",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 20,
          "snippet": "{ name: 'dextools/dexscreener', re: /dexscreener|DexScreener|dexTop|dexTop/g },",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 20,
          "snippet": "{ name: 'dextools/dexscreener', re: /dexscreener|DexScreener|dexTop|dexTop/g },",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 20,
          "snippet": "{ name: 'dextools/dexscreener', re: /dexscreener|DexScreener|dexTop|dexTop/g },",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 21,
          "snippet": "{ name: 'ws_listener', re: /WsListener|heliusWsListener|wsListener|notifier/g },",
          "pattern": "ws_listener"
        },
        {
          "line": 21,
          "snippet": "{ name: 'ws_listener', re: /WsListener|heliusWsListener|wsListener|notifier/g },",
          "pattern": "ws_listener"
        },
        {
          "line": 21,
          "snippet": "{ name: 'ws_listener', re: /WsListener|heliusWsListener|wsListener|notifier/g },",
          "pattern": "ws_listener"
        },
        {
          "line": 21,
          "snippet": "{ name: 'ws_listener', re: /WsListener|heliusWsListener|wsListener|notifier/g },",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "src/autoStrategyExecutor.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 2,
          "snippet": "import { unifiedBuy, unifiedSell } from './tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 2,
          "snippet": "import { unifiedBuy, unifiedSell } from './tradeSources';",
          "pattern": "unified_trade"
        }
      ]
    },
    {
      "file": "src/autoStrategyExecutor.ts",
      "func": "export async function autoExecuteStrategyForUser(user: any, tokens: any[], mode: 'buy' | 'sell' = 'buy') {",
      "hits": [
        {
          "line": 39,
          "snippet": "result = await unifiedBuy(tokenAddress, buyAmount, user.secret);",
          "pattern": "unified_trade"
        },
        {
          "line": 45,
          "snippet": "result = await unifiedSell(tokenAddress, sellAmount, user.secret);",
          "pattern": "unified_trade"
        }
      ]
    },
    {
      "file": "src/bot/buySellHandlers.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 1,
          "snippet": "import { unifiedBuy, unifiedSell } from '../tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 1,
          "snippet": "import { unifiedBuy, unifiedSell } from '../tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 58,
          "snippet": "const result = await unifiedSell(tokenAddress, amount, user.secret);",
          "pattern": "unified_trade"
        },
        {
          "line": 62,
          "snippet": "const entry = `Sell: ${tokenAddress} | Amount: ${amount} SOL | Source: unifiedSell | Tx: ${result.tx}`;",
          "pattern": "unified_trade"
        }
      ]
    },
    {
      "file": "src/bot/buySellHandlers.ts",
      "func": "export function registerBuySellHandlers(bot: any, users: Record<string, any>, boughtTokens: Record<string, Set<string>>) {",
      "hits": [
        {
          "line": 27,
          "snippet": "const result = await unifiedBuy(tokenAddress, amount, user.secret);",
          "pattern": "unified_trade"
        },
        {
          "line": 32,
          "snippet": "const entry = `ManualBuy: ${tokenAddress} | Amount: ${amount} SOL | Source: unifiedBuy | Tx: ${result.tx}`;",
          "pattern": "unified_trade"
        }
      ]
    },
    {
      "file": "src/bot/enrichQueue.ts",
      "func": "export async function startEnrichQueue(telegram: any, users: Record<string, any>, opts?: Partial<typeof workerOpts>) {",
      "hits": [
        {
          "line": 51,
          "snippet": "const autoFilter = tokenUtils.autoFilterTokens;",
          "pattern": "enrich"
        },
        {
          "line": 52,
          "snippet": "const enrichTokenTimestamps = tokenUtils.enrichTokenTimestamps;",
          "pattern": "enrich"
        },
        {
          "line": 52,
          "snippet": "const enrichTokenTimestamps = tokenUtils.enrichTokenTimestamps;",
          "pattern": "enrich"
        },
        {
          "line": 50,
          "snippet": "const fetchDex = tokenUtils.fetchDexScreenerTokens;",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/bot/enrichQueue.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 81,
          "snippet": "try { if (allowEnrichment()) await enrichTokenTimestamps(toEnrich, { batchSize: 3, delayMs: 400 }); } catch (e) {}",
          "pattern": "enrich"
        },
        {
          "line": 1,
          "snippet": "import { HELIUS_ENRICH_LIMIT } from '../config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 79,
          "snippet": "const enrichLimit = Number(HELIUS_ENRICH_LIMIT || 8);",
          "pattern": "rpc_helius"
        },
        {
          "line": 110,
          "snippet": "// Only trust explicit collector-provided URLs; do NOT construct DexScreener links from pairAddress.",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 113,
          "snippet": "const body = `• ${name} (<code>${address}</code>)\\nPrice: ${price} USD\\n<a href='${dexUrl}'>DexScreener</a> | <a href='https://solscan.io/token/${address}'>Solscan</a>`;",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 97,
          "snippet": "// is the single authoritative notifier for explicit-created tokens.",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "src/bot/strategy.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 562,
          "snippet": "// Prefer capture-based age when available (listener capture time). This reflects \"age since collectFreshMints\".",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 356,
          "snippet": "// prepare fast probe helper (prefer local fastTokenFetcher if available)",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 358,
          "snippet": "try { ff = await import('../fastTokenFetcher'); } catch (e) { try { ff = require('../dist/src/fastTokenFetcher'); } catch(_) { ff = null; } }",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 358,
          "snippet": "try { ff = await import('../fastTokenFetcher'); } catch (e) { try { ff = require('../dist/src/fastTokenFetcher'); } catch(_) { ff = null; } }",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 376,
          "snippet": "if (ff && typeof ff.fetchFirstSignatureForMint === 'function') {",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 377,
          "snippet": "const probe = await ff.fetchFirstSignatureForMint(tkn.tokenAddress || tkn.mint || tkn.address).catch(() => null);",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 412,
          "snippet": "// operate on a richer, corroborated set. Use existing fastTokenFetcher helper to gather latest candidates.",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 414,
          "snippet": "const ff = await import('../fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 415,
          "snippet": "const latest = await ff.fetchLatest5FromAllSources(10).catch(() => null);",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 273,
          "snippet": "import { autoFilterTokensVerbose } from '../utils/tokenUtils';",
          "pattern": "enrich"
        },
        {
          "line": 444,
          "snippet": "enrichPromise = utils.enrichTokenTimestamps(tokens, {",
          "pattern": "enrich"
        },
        {
          "line": 465,
          "snippet": "const { getField, autoFilterTokens, parseDuration } = utils;",
          "pattern": "enrich"
        },
        {
          "line": 467,
          "snippet": "// 1) Fast pass: use `autoFilterTokensVerbose` for the simple numeric checks (marketCap, liquidity, volume, basic age rules)",
          "pattern": "enrich"
        },
        {
          "line": 468,
          "snippet": "const prelimVerbose = autoFilterTokensVerbose(tokens, strategy);",
          "pattern": "enrich"
        },
        {
          "line": 501,
          "snippet": "// officialEnrich mutates the token in-place with poolOpenTimeMs, liquidity, volume, freshnessScore",
          "pattern": "enrich"
        },
        {
          "line": 504,
          "snippet": "await tu.officialEnrich(tokenObj, { amountUsd: Number(strategy.buyAmount) || undefined, timeoutMs });",
          "pattern": "enrich"
        },
        {
          "line": 556,
          "snippet": "// Holders check (may not be covered by autoFilterTokens depending on STRATEGY_FIELDS)",
          "pattern": "enrich"
        },
        {
          "line": 272,
          "snippet": "import { HELIUS_BATCH_SIZE, HELIUS_BATCH_DELAY_MS, ONCHAIN_FRESHNESS_TIMEOUT_MS } from '../config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 272,
          "snippet": "import { HELIUS_BATCH_SIZE, HELIUS_BATCH_DELAY_MS, ONCHAIN_FRESHNESS_TIMEOUT_MS } from '../config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 404,
          "snippet": "// using Helius (RPC/parse/websocket), Solscan and RPC fallbacks. This improves age",
          "pattern": "rpc_helius"
        },
        {
          "line": 411,
          "snippet": "// Merge realtime sources (Helius WS buffer, DexScreener top, Helius parse-history) so filters",
          "pattern": "rpc_helius"
        },
        {
          "line": 411,
          "snippet": "// Merge realtime sources (Helius WS buffer, DexScreener top, Helius parse-history) so filters",
          "pattern": "rpc_helius"
        },
        {
          "line": 419,
          "snippet": "(latest.heliusEvents || []).forEach(pushAddr);",
          "pattern": "rpc_helius"
        },
        {
          "line": 421,
          "snippet": "(latest.heliusHistory || []).forEach(pushAddr);",
          "pattern": "rpc_helius"
        },
        {
          "line": 445,
          "snippet": "batchSize: Number(HELIUS_BATCH_SIZE || 6),",
          "pattern": "rpc_helius"
        },
        {
          "line": 446,
          "snippet": "delayMs: Number(HELIUS_BATCH_DELAY_MS || 300)",
          "pattern": "rpc_helius"
        },
        {
          "line": 458,
          "snippet": "try{ traceFlow('filterTokensByStrategy:enrichment_started', { batchSize: Number(HELIUS_BATCH_SIZE || 6) }); }catch(e){}",
          "pattern": "rpc_helius"
        },
        {
          "line": 7,
          "snippet": "import { unifiedBuy, unifiedSell } from '../tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 7,
          "snippet": "import { unifiedBuy, unifiedSell } from '../tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 411,
          "snippet": "// Merge realtime sources (Helius WS buffer, DexScreener top, Helius parse-history) so filters",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 420,
          "snippet": "(latest.dexTop || []).forEach(pushAddr);",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/bot/strategy.ts",
      "func": "export async function filterTokensByStrategy(tokens: any[], strategy: Strategy, opts?: { preserveSources?: boolean, fastOnly?: boolean }): Promise<any[]> {",
      "hits": [
        {
          "line": 322,
          "snippet": "const looksLikeListener = tokens.length > 0 && tokens.every(t => t && (t.sourceProgram || t.sourceSignature || t.sourceCandidates || (t.sourceTags && Array.isArray(t.sourceTags) && t.sourceTags.some((s: string) => /helius|listener|ws|dexscreener/i.test(s) ))));",
          "pattern": "rpc_helius"
        },
        {
          "line": 322,
          "snippet": "const looksLikeListener = tokens.length > 0 && tokens.every(t => t && (t.sourceProgram || t.sourceSignature || t.sourceCandidates || (t.sourceTags && Array.isArray(t.sourceTags) && t.sourceTags.some((s: string) => /helius|listener|ws|dexscreener/i.test(s) ))));",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/bot/strategy.ts",
      "func": "export async function monitorAndAutoSellTrades(user: any, tokens: any[], priceField = 'price') {",
      "hits": [
        {
          "line": 198,
          "snippet": "const result = await unifiedSell(token.address, sell.amount, user.secret /*, { slippage: user.strategy.slippage }*/);",
          "pattern": "unified_trade"
        }
      ]
    },
    {
      "file": "src/bot/strategy.ts",
      "func": "export async function executeBatchTradesForUser(user: any, tokens: any[], mode: 'buy' | 'sell' = 'buy', delayMs = 2000) {",
      "hits": [
        {
          "line": 237,
          "snippet": "result = await unifiedBuy(token.address, amount, user.secret /*, { slippage }*/);",
          "pattern": "unified_trade"
        },
        {
          "line": 243,
          "snippet": "result = await unifiedSell(token.address, amount, user.secret /*, { slippage }*/);",
          "pattern": "unified_trade"
        }
      ]
    },
    {
      "file": "src/config.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 27,
          "snippet": "export const MAINNET_RPC = process.env.MAINNET_RPC || process.env.HELIUS_RPC_URL || 'https://api.mainnet-beta.solana.com';",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/config.ts",
      "func": "export function getJupiterApiKey(rotate = true): string | null {",
      "hits": [
        {
          "line": 70,
          "snippet": "// Helius specific envs",
          "pattern": "rpc_helius"
        },
        {
          "line": 71,
          "snippet": "export const HELIUS_API_KEY = process.env.HELIUS_API_KEY || process.env.HELIUS_KEY || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 71,
          "snippet": "export const HELIUS_API_KEY = process.env.HELIUS_API_KEY || process.env.HELIUS_KEY || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 71,
          "snippet": "export const HELIUS_API_KEY = process.env.HELIUS_API_KEY || process.env.HELIUS_KEY || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 72,
          "snippet": "// Support multiple Helius API keys via comma-separated env var HELIUS_API_KEYS",
          "pattern": "rpc_helius"
        },
        {
          "line": 72,
          "snippet": "// Support multiple Helius API keys via comma-separated env var HELIUS_API_KEYS",
          "pattern": "rpc_helius"
        },
        {
          "line": 73,
          "snippet": "export const HELIUS_API_KEYS: string[] = (process.env.HELIUS_API_KEYS || '')",
          "pattern": "rpc_helius"
        },
        {
          "line": 73,
          "snippet": "export const HELIUS_API_KEYS: string[] = (process.env.HELIUS_API_KEYS || '')",
          "pattern": "rpc_helius"
        },
        {
          "line": 79,
          "snippet": "let __heliusKeyIndex = 0;",
          "pattern": "rpc_helius"
        },
        {
          "line": 82,
          "snippet": "* Get a Helius API key. If multiple keys are configured via HELIUS_API_KEYS,",
          "pattern": "rpc_helius"
        },
        {
          "line": 82,
          "snippet": "* Get a Helius API key. If multiple keys are configured via HELIUS_API_KEYS,",
          "pattern": "rpc_helius"
        },
        {
          "line": 84,
          "snippet": "* configured, it falls back to HELIUS_API_KEY.",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/config.ts",
      "func": "export function getHeliusApiKey(rotate = true): string {",
      "hits": [
        {
          "line": 88,
          "snippet": "export function getHeliusApiKey(rotate = true): string {",
          "pattern": "rpc_helius"
        },
        {
          "line": 90,
          "snippet": "if (Array.isArray(HELIUS_API_KEYS) && HELIUS_API_KEYS.length > 0) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 90,
          "snippet": "if (Array.isArray(HELIUS_API_KEYS) && HELIUS_API_KEYS.length > 0) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 91,
          "snippet": "const key = HELIUS_API_KEYS[__heliusKeyIndex % HELIUS_API_KEYS.length];",
          "pattern": "rpc_helius"
        },
        {
          "line": 91,
          "snippet": "const key = HELIUS_API_KEYS[__heliusKeyIndex % HELIUS_API_KEYS.length];",
          "pattern": "rpc_helius"
        },
        {
          "line": 91,
          "snippet": "const key = HELIUS_API_KEYS[__heliusKeyIndex % HELIUS_API_KEYS.length];",
          "pattern": "rpc_helius"
        },
        {
          "line": 92,
          "snippet": "if (rotate) __heliusKeyIndex = (__heliusKeyIndex + 1) % HELIUS_API_KEYS.length;",
          "pattern": "rpc_helius"
        },
        {
          "line": 92,
          "snippet": "if (rotate) __heliusKeyIndex = (__heliusKeyIndex + 1) % HELIUS_API_KEYS.length;",
          "pattern": "rpc_helius"
        },
        {
          "line": 92,
          "snippet": "if (rotate) __heliusKeyIndex = (__heliusKeyIndex + 1) % HELIUS_API_KEYS.length;",
          "pattern": "rpc_helius"
        },
        {
          "line": 96,
          "snippet": "return HELIUS_API_KEY;",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/config.ts",
      "func": "export function maskKey(k: string | null | undefined): string {",
      "hits": [
        {
          "line": 107,
          "snippet": "export const HELIUS_WS_URL_RAW = process.env.HELIUS_WEBSOCKET_URL || process.env.HELIUS_FAST_RPC_URL || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 107,
          "snippet": "export const HELIUS_WS_URL_RAW = process.env.HELIUS_WEBSOCKET_URL || process.env.HELIUS_FAST_RPC_URL || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 107,
          "snippet": "export const HELIUS_WS_URL_RAW = process.env.HELIUS_WEBSOCKET_URL || process.env.HELIUS_FAST_RPC_URL || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 108,
          "snippet": "export const HELIUS_RPC_URL = process.env.HELIUS_RPC_URL || process.env.MAINNET_RPC || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 108,
          "snippet": "export const HELIUS_RPC_URL = process.env.HELIUS_RPC_URL || process.env.MAINNET_RPC || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 109,
          "snippet": "export const HELIUS_PARSE_HISTORY_URL = process.env.HELIUS_PARSE_HISTORY_URL || process.env.HELIUS_PARSE_TX_URL || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 109,
          "snippet": "export const HELIUS_PARSE_HISTORY_URL = process.env.HELIUS_PARSE_HISTORY_URL || process.env.HELIUS_PARSE_TX_URL || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 109,
          "snippet": "export const HELIUS_PARSE_HISTORY_URL = process.env.HELIUS_PARSE_HISTORY_URL || process.env.HELIUS_PARSE_TX_URL || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 110,
          "snippet": "export const HELIUS_USE_WEBSOCKET = (process.env.HELIUS_USE_WEBSOCKET || 'false').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 110,
          "snippet": "export const HELIUS_USE_WEBSOCKET = (process.env.HELIUS_USE_WEBSOCKET || 'false').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 111,
          "snippet": "export const HELIUS_SUBSCRIBE_METADATA = (process.env.HELIUS_SUBSCRIBE_METADATA || 'true').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 111,
          "snippet": "export const HELIUS_SUBSCRIBE_METADATA = (process.env.HELIUS_SUBSCRIBE_METADATA || 'true').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 112,
          "snippet": "export const HELIUS_SUBSCRIBE_SPLTOKEN = (process.env.HELIUS_SUBSCRIBE_SPLTOKEN || 'true').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 112,
          "snippet": "export const HELIUS_SUBSCRIBE_SPLTOKEN = (process.env.HELIUS_SUBSCRIBE_SPLTOKEN || 'true').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 113,
          "snippet": "// Additional Helius tuning envs",
          "pattern": "rpc_helius"
        },
        {
          "line": 114,
          "snippet": "export const HELIUS_CACHE_TTL_MS = Number(process.env.HELIUS_CACHE_TTL_MS || 24 * 60 * 60 * 1000);",
          "pattern": "rpc_helius"
        },
        {
          "line": 114,
          "snippet": "export const HELIUS_CACHE_TTL_MS = Number(process.env.HELIUS_CACHE_TTL_MS || 24 * 60 * 60 * 1000);",
          "pattern": "rpc_helius"
        },
        {
          "line": 115,
          "snippet": "export const HELIUS_RETRY_MAX_ATTEMPTS = Number(process.env.HELIUS_RETRY_MAX_ATTEMPTS || 1);",
          "pattern": "rpc_helius"
        },
        {
          "line": 115,
          "snippet": "export const HELIUS_RETRY_MAX_ATTEMPTS = Number(process.env.HELIUS_RETRY_MAX_ATTEMPTS || 1);",
          "pattern": "rpc_helius"
        },
        {
          "line": 116,
          "snippet": "export const HELIUS_RETRY_BASE_MS = Number(process.env.HELIUS_RETRY_BASE_MS || 500);",
          "pattern": "rpc_helius"
        },
        {
          "line": 116,
          "snippet": "export const HELIUS_RETRY_BASE_MS = Number(process.env.HELIUS_RETRY_BASE_MS || 500);",
          "pattern": "rpc_helius"
        },
        {
          "line": 117,
          "snippet": "export const HELIUS_RETRY_JITTER_MS = Number(process.env.HELIUS_RETRY_JITTER_MS || 300);",
          "pattern": "rpc_helius"
        },
        {
          "line": 117,
          "snippet": "export const HELIUS_RETRY_JITTER_MS = Number(process.env.HELIUS_RETRY_JITTER_MS || 300);",
          "pattern": "rpc_helius"
        },
        {
          "line": 118,
          "snippet": "export const HELIUS_FALLBACK_ENABLED = (process.env.HELIUS_FALLBACK_ENABLED || 'true').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 118,
          "snippet": "export const HELIUS_FALLBACK_ENABLED = (process.env.HELIUS_FALLBACK_ENABLED || 'true').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 119,
          "snippet": "export const HELIUS_SIG_LIMIT = Number(process.env.HELIUS_SIG_LIMIT || 20);",
          "pattern": "rpc_helius"
        },
        {
          "line": 119,
          "snippet": "export const HELIUS_SIG_LIMIT = Number(process.env.HELIUS_SIG_LIMIT || 20);",
          "pattern": "rpc_helius"
        },
        {
          "line": 120,
          "snippet": "export const HELIUS_RPC_CONCURRENCY = Number(process.env.HELIUS_RPC_CONCURRENCY || 2);",
          "pattern": "rpc_helius"
        },
        {
          "line": 120,
          "snippet": "export const HELIUS_RPC_CONCURRENCY = Number(process.env.HELIUS_RPC_CONCURRENCY || 2);",
          "pattern": "rpc_helius"
        },
        {
          "line": 121,
          "snippet": "export const HELIUS_BATCH_SIZE = Number(process.env.HELIUS_BATCH_SIZE || 4);",
          "pattern": "rpc_helius"
        },
        {
          "line": 121,
          "snippet": "export const HELIUS_BATCH_SIZE = Number(process.env.HELIUS_BATCH_SIZE || 4);",
          "pattern": "rpc_helius"
        },
        {
          "line": 122,
          "snippet": "export const HELIUS_BATCH_DELAY_MS = Number(process.env.HELIUS_BATCH_DELAY_MS || 400);",
          "pattern": "rpc_helius"
        },
        {
          "line": 122,
          "snippet": "export const HELIUS_BATCH_DELAY_MS = Number(process.env.HELIUS_BATCH_DELAY_MS || 400);",
          "pattern": "rpc_helius"
        },
        {
          "line": 123,
          "snippet": "export const HELIUS_ENRICH_LIMIT = Number(process.env.HELIUS_ENRICH_LIMIT || 8);",
          "pattern": "rpc_helius"
        },
        {
          "line": 123,
          "snippet": "export const HELIUS_ENRICH_LIMIT = Number(process.env.HELIUS_ENRICH_LIMIT || 8);",
          "pattern": "rpc_helius"
        },
        {
          "line": 132,
          "snippet": "// Build Helius WebSocket URL (append API key if needed)",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/config.ts",
      "func": "export function getHeliusWebsocketUrl(): string {",
      "hits": [
        {
          "line": 133,
          "snippet": "export function getHeliusWebsocketUrl(): string {",
          "pattern": "rpc_helius"
        },
        {
          "line": 134,
          "snippet": "let base = HELIUS_WS_URL_RAW || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 140,
          "snippet": "const heliusKey = getHeliusApiKey();",
          "pattern": "rpc_helius"
        },
        {
          "line": 140,
          "snippet": "const heliusKey = getHeliusApiKey();",
          "pattern": "rpc_helius"
        },
        {
          "line": 141,
          "snippet": "if (heliusKey && !u.searchParams.get('api-key') && !u.searchParams.get('x-api-key') && !u.searchParams.get('key')) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 142,
          "snippet": "u.searchParams.set('x-api-key', heliusKey);",
          "pattern": "rpc_helius"
        },
        {
          "line": 147,
          "snippet": "if (HELIUS_API_KEY && base.indexOf('?') === -1) return `${base}?x-api-key=${HELIUS_API_KEY}`;",
          "pattern": "rpc_helius"
        },
        {
          "line": 147,
          "snippet": "if (HELIUS_API_KEY && base.indexOf('?') === -1) return `${base}?x-api-key=${HELIUS_API_KEY}`;",
          "pattern": "rpc_helius"
        },
        {
          "line": 148,
          "snippet": "if (HELIUS_API_KEY) return `${base}&x-api-key=${HELIUS_API_KEY}`;",
          "pattern": "rpc_helius"
        },
        {
          "line": 148,
          "snippet": "if (HELIUS_API_KEY) return `${base}&x-api-key=${HELIUS_API_KEY}`;",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 1,
          "snippet": "import axios from 'axios';",
          "pattern": "axios"
        },
        {
          "line": 1,
          "snippet": "import axios from 'axios';",
          "pattern": "axios"
        },
        {
          "line": 2132,
          "snippet": "const sresWrap = await withTimeout(axios.get(solscanUrl, { timeout: timeoutMs, headers }), timeoutMs + 200);",
          "pattern": "axios"
        },
        {
          "line": 509,
          "snippet": "// 3) fetchLatest5FromAllSources for extra corroboration",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 511,
          "snippet": "const subs = await fetchLatest5FromAllSources(Math.max(5, limit));",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 1796,
          "snippet": "try { const t = await import('./utils/trace'); t.traceFlow('fastTokenFetcher:handleNewMintEvent:selection', { mint, chosenReason, metadataTimestampUsed: !!metadataTimestampUsed, firstSignature: firstSignature || null, earliestBlockTime: earliestBlockTime || null, ageSeconds: ageSeconds || null }); } catch(e){}",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 1887,
          "snippet": "try { const t = await import('./utils/trace'); t.traceFlow('fastTokenFetcher:handleNewMintEvent:validated',{ mint, firstBlockTime: earliestBlockTime, ageSeconds, metadataExists, supply }); } catch(e){}",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 1890,
          "snippet": "try { const t = await import('./utils/trace'); t.traceFlow('fastTokenFetcher:handleNewMintEvent:candidate',{ mint, firstBlockTime: earliestBlockTime, ageSeconds, metadataExists, supply }); } catch(e){}",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 1986,
          "snippet": "try { const t = await import('./utils/trace'); t.traceFlow('fastTokenFetcher:handleNewMintEventCached:inflight_set',{ mint, key }); } catch(e){}",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 2459,
          "snippet": "// If run directly with command `node fastTokenFetcher.js latest` print latest 5 from each source",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 2464,
          "snippet": "const res = await fetchLatest5FromAllSources(5);",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 811,
          "snippet": "const { officialEnrich, checkOnChainActivity } = require('./utils/tokenUtils');",
          "pattern": "enrich"
        },
        {
          "line": 44,
          "snippet": "import { JUPITER_QUOTE_API, HELIUS_RPC_URL, SOLSCAN_API_URL, HELIUS_PARSE_HISTORY_URL, HELIUS_API_KEY, getHeliusApiKey, getSolscanApiKey } from './config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 44,
          "snippet": "import { JUPITER_QUOTE_API, HELIUS_RPC_URL, SOLSCAN_API_URL, HELIUS_PARSE_HISTORY_URL, HELIUS_API_KEY, getHeliusApiKey, getSolscanApiKey } from './config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 44,
          "snippet": "import { JUPITER_QUOTE_API, HELIUS_RPC_URL, SOLSCAN_API_URL, HELIUS_PARSE_HISTORY_URL, HELIUS_API_KEY, getHeliusApiKey, getSolscanApiKey } from './config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 44,
          "snippet": "import { JUPITER_QUOTE_API, HELIUS_RPC_URL, SOLSCAN_API_URL, HELIUS_PARSE_HISTORY_URL, HELIUS_API_KEY, getHeliusApiKey, getSolscanApiKey } from './config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 512,
          "snippet": "for (const arr of [subs.heliusEvents || [], subs.dexTop || [], subs.heliusHistory || []]) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 512,
          "snippet": "for (const arr of [subs.heliusEvents || [], subs.dexTop || [], subs.heliusHistory || []]) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 1142,
          "snippet": "// --- Helpers: lightweight helius/json-rpc wrapper and verification helpers",
          "pattern": "rpc_helius"
        },
        {
          "line": 1208,
          "snippet": "// Helper: check whether a mint has been seen previously according to Helius signature history",
          "pattern": "rpc_helius"
        },
        {
          "line": 1575,
          "snippet": "// export for external quick lookups (heliusWsListener uses this)",
          "pattern": "rpc_helius"
        },
        {
          "line": 1719,
          "snippet": "const deepRes = await heliusRpc('getSignaturesForAddress', [mint, { limit: deepLimit }], 8000, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1765,
          "snippet": "const metaSigsRes = await heliusGetSignaturesFast(metadataPda, heliusUrl, 4000, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1765,
          "snippet": "const metaSigsRes = await heliusGetSignaturesFast(metadataPda, heliusUrl, 4000, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1801,
          "snippet": "const arr = (await heliusGetSignaturesFast(mint, heliusUrl, 2000, 0)) || [];",
          "pattern": "rpc_helius"
        },
        {
          "line": 1801,
          "snippet": "const arr = (await heliusGetSignaturesFast(mint, heliusUrl, 2000, 0)) || [];",
          "pattern": "rpc_helius"
        },
        {
          "line": 1909,
          "snippet": "const _hh_handle_cache_ttl_ms = Number(process.env.HELIUS_HANDLE_CACHE_TTL_MS || (process.env.HELIUS_HANDLE_CACHE_TTL_S ? Number(process.env.HELIUS_HANDLE_CACHE_TTL_S) * 1000 : 60_000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1909,
          "snippet": "const _hh_handle_cache_ttl_ms = Number(process.env.HELIUS_HANDLE_CACHE_TTL_MS || (process.env.HELIUS_HANDLE_CACHE_TTL_S ? Number(process.env.HELIUS_HANDLE_CACHE_TTL_S) * 1000 : 60_000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1909,
          "snippet": "const _hh_handle_cache_ttl_ms = Number(process.env.HELIUS_HANDLE_CACHE_TTL_MS || (process.env.HELIUS_HANDLE_CACHE_TTL_S ? Number(process.env.HELIUS_HANDLE_CACHE_TTL_S) * 1000 : 60_000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1919,
          "snippet": "const _hh_max = Number(process.env.HELIUS_HANDLE_CONCURRENCY ?? 3);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2098,
          "snippet": "// try alternate helius rpc if available",
          "pattern": "rpc_helius"
        },
        {
          "line": 2099,
          "snippet": "const alt = HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 2100,
          "snippet": "if (alt && alt !== heliusUrl) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 2101,
          "snippet": "const r2 = await heliusGetSignaturesFast(t.mint, alt, timeoutMs, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2103,
          "snippet": "// try direct rpc via heliusRpc",
          "pattern": "rpc_helius"
        },
        {
          "line": 2105,
          "snippet": "const r3 = await heliusRpc('getSignaturesForAddress', [t.mint, { limit: 3 }], timeoutMs, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2113,
          "snippet": "results.push({ mint: t.mint, firstBlockTime: btMs, ageSeconds: Math.max(0, Math.floor((Date.now() - btMs) / 1000)), source: 'helius-rpc', earliestSignature: (f3 && (f3.signature || (f3 as any).txHash || (f3 as any).tx_hash)) || null });",
          "pattern": "rpc_helius"
        },
        {
          "line": 2211,
          "snippet": "results.push({ mint: t.mint, firstBlockTime: btMs, ageSeconds: Math.max(0, Math.floor((Date.now() - btMs) / 1000)), source: 'helius-rpc', earliestSignature: sig2 || null });",
          "pattern": "rpc_helius"
        },
        {
          "line": 2217,
          "snippet": "// if no alt configured or alt equals heliusUrl, just emit the original error",
          "pattern": "rpc_helius"
        },
        {
          "line": 2301,
          "snippet": "results.push({ mint: t.mint, firstBlockTime: btMs, ageSeconds: Math.max(0, Math.floor((Date.now() - btMs) / 1000)), source: 'helius-fast', earliestSignature: earliestSig || null });",
          "pattern": "rpc_helius"
        },
        {
          "line": 2328,
          "snippet": "// Fetch latest N unique mints from multiple sources: Helius WS recent events, DexScreener boosts, and Solana RPC (via Helius parse-history)",
          "pattern": "rpc_helius"
        },
        {
          "line": 2328,
          "snippet": "// Fetch latest N unique mints from multiple sources: Helius WS recent events, DexScreener boosts, and Solana RPC (via Helius parse-history)",
          "pattern": "rpc_helius"
        },
        {
          "line": 2373,
          "snippet": "heliusHistory.push(c);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2376,
          "snippet": "if (heliusHistory.length >= n) break;",
          "pattern": "rpc_helius"
        },
        {
          "line": 2381,
          "snippet": "// Optional validation via helius getAccountInfo to ensure the mint/account exists (reduce 404s)",
          "pattern": "rpc_helius"
        },
        {
          "line": 2382,
          "snippet": "const shouldValidate = (process.env.HELIUS_VALIDATE_ACCOUNTS || 'false').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 2465,
          "snippet": "console.log('Latest from Helius WS buffer:', res.heliusEvents);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2465,
          "snippet": "console.log('Latest from Helius WS buffer:', res.heliusEvents);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2467,
          "snippet": "console.log('Helius parse-history hits:', res.heliusHistory);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2467,
          "snippet": "console.log('Helius parse-history hits:', res.heliusHistory);",
          "pattern": "rpc_helius"
        },
        {
          "line": 4,
          "snippet": "import { createClient } from 'redis';",
          "pattern": "redis"
        },
        {
          "line": 58,
          "snippet": "let __redisClient: any = null;",
          "pattern": "redis"
        },
        {
          "line": 8,
          "snippet": "import { unifiedBuy } from './tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 281,
          "snippet": "const result = await unifiedBuy(addr, amount, u.secret);",
          "pattern": "unified_trade"
        },
        {
          "line": 1866,
          "snippet": "const result = await unifiedBuy(mint, amount, u.secret);",
          "pattern": "unified_trade"
        },
        {
          "line": 9,
          "snippet": "import { fetchDexScreenerTokens, fetchSolanaFromCoinGecko, normalizeMintCandidate } from './utils/tokenUtils';",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 13,
          "snippet": "'So11111111111111111111111111111111111111112', // wrapped SOL sentinel often shown in dexscreener samples",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 196,
          "snippet": "* Start fast polling of DexScreener boosts endpoint and prioritize users flagged in their strategy.",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 512,
          "snippet": "for (const arr of [subs.heliusEvents || [], subs.dexTop || [], subs.heliusHistory || []]) {",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 584,
          "snippet": "* Fetch tokens from common sources (DexScreener, CoinGecko fallback) once,",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 658,
          "snippet": "// Proactively merge DexScreener token/pair data into the global cache so",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 663,
          "snippet": "const ds = await fetchDexScreenerTokens('solana', { limit: String(limit) });",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 704,
          "snippet": "if (!existing.sourceTags.includes('dexscreener')) existing.sourceTags.push('dexscreener');",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 704,
          "snippet": "if (!existing.sourceTags.includes('dexscreener')) existing.sourceTags.push('dexscreener');",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 733,
          "snippet": "newEntry.sourceTags = ['dexscreener'];",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 748,
          "snippet": "// DexScreener call failed; continue silently",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 750,
          "snippet": "// After merging dexscreener data, run a quick equivalence report to detect discrepancies",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 2328,
          "snippet": "// Fetch latest N unique mints from multiple sources: Helius WS recent events, DexScreener boosts, and Solana RPC (via Helius parse-history)",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 2466,
          "snippet": "console.log('Top from DexScreener:', res.dexTop);",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 2466,
          "snippet": "console.log('Top from DexScreener:', res.dexTop);",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 1575,
          "snippet": "// export for external quick lookups (heliusWsListener uses this)",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function fetchDexBoostsRaw(timeout = 3000) {",
      "hits": [
        {
          "line": 1059,
          "snippet": "const p = axios.get(url, { timeout });",
          "pattern": "axios"
        },
        {
          "line": 1046,
          "snippet": "// If running in listener-only mode, avoid external DexScreener calls.",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 1048,
          "snippet": "return { __meta: makeSourceMeta('dexscreener', false, { error: 'listener-only' }), data: [] } as any;",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 1065,
          "snippet": "return { __meta: makeSourceMeta('dexscreener', true, { latencyMs: Date.now() - start, raw: res.data }), data: res.data } as any;",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 1068,
          "snippet": "return { __meta: makeSourceMeta('dexscreener', false, { error: errMsg, latencyMs: Date.now() - start }) } as any;",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function heliusGetSignaturesFast(mint: string, heliusUrl: string, timeout = 2500, retries = 0) {",
      "hits": [
        {
          "line": 1114,
          "snippet": "const p = axios.post(heliusUrl, payload, { headers, timeout });",
          "pattern": "axios"
        },
        {
          "line": 1090,
          "snippet": "export async function heliusGetSignaturesFast(mint: string, heliusUrl: string, timeout = 2500, retries = 0) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 1090,
          "snippet": "export async function heliusGetSignaturesFast(mint: string, heliusUrl: string, timeout = 2500, retries = 0) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 1093,
          "snippet": "(globalThis as any).__heliusSigCache = (globalThis as any).__heliusSigCache || new TTLCache<string, any>(Number(process.env.HELIUS_SIG_CACHE_MS || 30_000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1093,
          "snippet": "(globalThis as any).__heliusSigCache = (globalThis as any).__heliusSigCache || new TTLCache<string, any>(Number(process.env.HELIUS_SIG_CACHE_MS || 30_000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1093,
          "snippet": "(globalThis as any).__heliusSigCache = (globalThis as any).__heliusSigCache || new TTLCache<string, any>(Number(process.env.HELIUS_SIG_CACHE_MS || 30_000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1094,
          "snippet": "const sigCache: TTLCache<string, any> = (globalThis as any).__heliusSigCache;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1095,
          "snippet": "const cacheKey = `${heliusUrl}::${mint}`;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1106,
          "snippet": "const host = (() => { try { return new URL(heliusUrl).host; } catch { return heliusUrl; } })();",
          "pattern": "rpc_helius"
        },
        {
          "line": 1106,
          "snippet": "const host = (() => { try { return new URL(heliusUrl).host; } catch { return heliusUrl; } })();",
          "pattern": "rpc_helius"
        },
        {
          "line": 1107,
          "snippet": "const limiter = getHostLimiter(host, Number(process.env.HELIUS_CONCURRENCY || 2));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1113,
          "snippet": "try { const _hk = getHeliusApiKey(); if (_hk) headers['x-api-key'] = _hk; } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 1114,
          "snippet": "const p = axios.post(heliusUrl, payload, { headers, timeout });",
          "pattern": "rpc_helius"
        },
        {
          "line": 1118,
          "snippet": "}, { retries: Math.max(0, retries || Number(process.env.HELIUS_RETRIES || 1)), baseMs: 200 });",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function heliusRpc(method: string, params: any[] = [], timeout = 4000, retries = 0): Promise<any> {",
      "hits": [
        {
          "line": 1171,
          "snippet": "const p = axios.post(heliusUrl, payload, { headers, timeout });",
          "pattern": "axios"
        },
        {
          "line": 1145,
          "snippet": "// Enforce collector-only policy: avoid making Helius RPC calls from fastTokenFetcher",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 1143,
          "snippet": "async function heliusRpc(method: string, params: any[] = [], timeout = 4000, retries = 0): Promise<any> {",
          "pattern": "rpc_helius"
        },
        {
          "line": 1145,
          "snippet": "// Enforce collector-only policy: avoid making Helius RPC calls from fastTokenFetcher",
          "pattern": "rpc_helius"
        },
        {
          "line": 1150,
          "snippet": "const heliusUrl = HELIUS_RPC_URL || process.env.HELIUS_FAST_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1150,
          "snippet": "const heliusUrl = HELIUS_RPC_URL || process.env.HELIUS_FAST_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1150,
          "snippet": "const heliusUrl = HELIUS_RPC_URL || process.env.HELIUS_FAST_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1151,
          "snippet": "if (!heliusUrl) return { __error: 'no-helius-url' };",
          "pattern": "rpc_helius"
        },
        {
          "line": 1151,
          "snippet": "if (!heliusUrl) return { __error: 'no-helius-url' };",
          "pattern": "rpc_helius"
        },
        {
          "line": 1153,
          "snippet": "const hostStateKey = (() => { try { return new URL(heliusUrl).host; } catch { return heliusUrl; } })();",
          "pattern": "rpc_helius"
        },
        {
          "line": 1153,
          "snippet": "const hostStateKey = (() => { try { return new URL(heliusUrl).host; } catch { return heliusUrl; } })();",
          "pattern": "rpc_helius"
        },
        {
          "line": 1165,
          "snippet": "const host = (() => { try { return new URL(heliusUrl).host; } catch { return heliusUrl; } })();",
          "pattern": "rpc_helius"
        },
        {
          "line": 1165,
          "snippet": "const host = (() => { try { return new URL(heliusUrl).host; } catch { return heliusUrl; } })();",
          "pattern": "rpc_helius"
        },
        {
          "line": 1166,
          "snippet": "const limiter = getHostLimiter(host, Number(process.env.HELIUS_CONCURRENCY || 2));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1170,
          "snippet": "try { const _hk = getHeliusApiKey(); if (_hk) headers['x-api-key'] = _hk; } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 1171,
          "snippet": "const p = axios.post(heliusUrl, payload, { headers, timeout });",
          "pattern": "rpc_helius"
        },
        {
          "line": 1175,
          "snippet": "}, { retries: Math.max(0, retries || Number(process.env.HELIUS_RETRIES || 1)), baseMs: 200 });",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function getParsedTransaction(signature: string) {",
      "hits": [
        {
          "line": 1334,
          "snippet": "const r = await axios.post(rpc, payload, { headers, timeout: 6000 });",
          "pattern": "axios"
        },
        {
          "line": 1316,
          "snippet": "// try Helius RPC wrapper first",
          "pattern": "rpc_helius"
        },
        {
          "line": 1317,
          "snippet": "let heliusRes: any = null;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1319,
          "snippet": "heliusRes = await heliusRpc('getTransaction', [signature, { encoding: 'jsonParsed' }], 5000, 1);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1319,
          "snippet": "heliusRes = await heliusRpc('getTransaction', [signature, { encoding: 'jsonParsed' }], 5000, 1);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1320,
          "snippet": "if (heliusRes && !(heliusRes as any).__error) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 1320,
          "snippet": "if (heliusRes && !(heliusRes as any).__error) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 1321,
          "snippet": "// If heliusRes contains result structure, return it",
          "pattern": "rpc_helius"
        },
        {
          "line": 1322,
          "snippet": "const candidate = heliusRes.result ?? heliusRes;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1322,
          "snippet": "const candidate = heliusRes.result ?? heliusRes;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1327,
          "snippet": "// fallback: if Helius is unavailable or returned error, try MAINNET_RPC (Solana JSON-RPC)",
          "pattern": "rpc_helius"
        },
        {
          "line": 1329,
          "snippet": "// prefer an explicit MAINNET RPC endpoint (do not reuse Helius RPC endpoint)",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function getBlockTimeForSlotCached(slot: number): Promise<number | null> {",
      "hits": [
        {
          "line": 1396,
          "snippet": "const r = await axios.post(mainRpc, payload, { timeout: 4000 });",
          "pattern": "axios"
        },
        {
          "line": 1373,
          "snippet": "const v = await rc.get(key).catch(() => null);",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function fetchLatest5FromAllSources(n = 5) {",
      "hits": [
        {
          "line": 2330,
          "snippet": "const axiosLocal = axios;",
          "pattern": "axios"
        },
        {
          "line": 2329,
          "snippet": "export async function fetchLatest5FromAllSources(n = 5) {",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 2331,
          "snippet": "const heliusEvents: string[] = [];",
          "pattern": "rpc_helius"
        },
        {
          "line": 2333,
          "snippet": "const { getRecentHeliusEvents } = require('./heliusWsListener');",
          "pattern": "rpc_helius"
        },
        {
          "line": 2333,
          "snippet": "const { getRecentHeliusEvents } = require('./heliusWsListener');",
          "pattern": "rpc_helius"
        },
        {
          "line": 2334,
          "snippet": "const evs = getRecentHeliusEvents();",
          "pattern": "rpc_helius"
        },
        {
          "line": 2336,
          "snippet": "if (e && e.mint) heliusEvents.push(e.mint);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2337,
          "snippet": "if (heliusEvents.length >= n) break;",
          "pattern": "rpc_helius"
        },
        {
          "line": 2359,
          "snippet": "// Solana parse history approach: use HELIUS_PARSE_HISTORY_URL template if available",
          "pattern": "rpc_helius"
        },
        {
          "line": 2360,
          "snippet": "const heliusHistory: string[] = [];",
          "pattern": "rpc_helius"
        },
        {
          "line": 2362,
          "snippet": "const parseUrlTemplate = HELIUS_PARSE_HISTORY_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 2341,
          "snippet": "// DexScreener top N (use limiter + structured meta)",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 2333,
          "snippet": "const { getRecentHeliusEvents } = require('./heliusWsListener');",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function fetchLatestWithSources(limit = 50) {",
      "hits": [
        {
          "line": 565,
          "snippet": "const subs = await fetchLatest5FromAllSources(Math.max(5, limit));",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 538,
          "snippet": "const { getRecentHeliusEvents } = require('./heliusWsListener');",
          "pattern": "rpc_helius"
        },
        {
          "line": 538,
          "snippet": "const { getRecentHeliusEvents } = require('./heliusWsListener');",
          "pattern": "rpc_helius"
        },
        {
          "line": 539,
          "snippet": "const evs = getRecentHeliusEvents() || [];",
          "pattern": "rpc_helius"
        },
        {
          "line": 543,
          "snippet": "if (m) out.push({ mint: m, source: 'helius-ws' });",
          "pattern": "rpc_helius"
        },
        {
          "line": 566,
          "snippet": "for (const m of subs.heliusEvents || []) if (m) out.push({ mint: m, source: 'helius-history' });",
          "pattern": "rpc_helius"
        },
        {
          "line": 566,
          "snippet": "for (const m of subs.heliusEvents || []) if (m) out.push({ mint: m, source: 'helius-history' });",
          "pattern": "rpc_helius"
        },
        {
          "line": 556,
          "snippet": "const entry: any = { mint: m, source: 'dexscreener' };",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 567,
          "snippet": "for (const m of subs.dexTop || []) if (m) out.push({ mint: m, source: 'dex-top' });",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 538,
          "snippet": "const { getRecentHeliusEvents } = require('./heliusWsListener');",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function fetchAndFilterTokensForUsers(users: UsersMap, opts?: { limit?: number, force?: boolean, detail?: boolean, warmupHeliusMs?: number }): Promise<Record<string, any[]>> {",
      "hits": [
        {
          "line": 616,
          "snippet": "try { if (typeof (globalThis as any).__fastTokenFetcher_getAccountInfo === 'function') return await (globalThis as any).__fastTokenFetcher_getAccountInfo(c.mint || c);",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 616,
          "snippet": "try { if (typeof (globalThis as any).__fastTokenFetcher_getAccountInfo === 'function') return await (globalThis as any).__fastTokenFetcher_getAccountInfo(c.mint || c);",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 618,
          "snippet": "if (typeof (require('./src/fastTokenFetcher').getAccountInfo) === 'function') return await require('./src/fastTokenFetcher').getAccountInfo(c.mint || c);",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 618,
          "snippet": "if (typeof (require('./src/fastTokenFetcher').getAccountInfo) === 'function') return await require('./src/fastTokenFetcher').getAccountInfo(c.mint || c);",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 588,
          "snippet": "export async function fetchAndFilterTokensForUsers(users: UsersMap, opts?: { limit?: number, force?: boolean, detail?: boolean, warmupHeliusMs?: number }): Promise<Record<string, any[]>> {",
          "pattern": "rpc_helius"
        },
        {
          "line": 596,
          "snippet": "// Optional warm-up: allow callers to request a Helius WS capture to populate events",
          "pattern": "rpc_helius"
        },
        {
          "line": 597,
          "snippet": "if (opts?.warmupHeliusMs && Number(opts.warmupHeliusMs) > 0) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 597,
          "snippet": "if (opts?.warmupHeliusMs && Number(opts.warmupHeliusMs) > 0) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 599,
          "snippet": "const ms = Number(opts.warmupHeliusMs);",
          "pattern": "rpc_helius"
        },
        {
          "line": 600,
          "snippet": "console.log('[fetchAndFilterTokensForUsers] running helius warm-up for', ms, 'ms');",
          "pattern": "rpc_helius"
        },
        {
          "line": 601,
          "snippet": "await captureHeliusAndVerify(ms).catch(() => {});",
          "pattern": "rpc_helius"
        },
        {
          "line": 627,
          "snippet": "// fetch unified candidates from multiple sources (DexScreener + Helius events/history + parse + RPC)",
          "pattern": "rpc_helius"
        },
        {
          "line": 627,
          "snippet": "// fetch unified candidates from multiple sources (DexScreener + Helius events/history + parse + RPC)",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function handleNewMintEvent(mintOrObj: any, users?: UsersMap, telegram?: any) {",
      "hits": [
        {
          "line": 1613,
          "snippet": "try { const t = await import('./utils/trace'); t.traceFlow('fastTokenFetcher:handleNewMintEvent:start',{ mint, payload: typeof mintOrObj === 'string' ? null : (mintOrObj && (mintOrObj.raw ? (mintOrObj.raw.params?.result || mintOrObj.raw.result) : mintOrObj)) }); } catch(e){}",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 1614,
          "snippet": "const heliusUrl = process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1614,
          "snippet": "const heliusUrl = process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1614,
          "snippet": "const heliusUrl = process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1615,
          "snippet": "if (!heliusUrl) { console.log('handleNewMintEvent: no helius url'); return null; }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1615,
          "snippet": "if (!heliusUrl) { console.log('handleNewMintEvent: no helius url'); return null; }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1617,
          "snippet": "// Prefer slot->getBlockTime when Helius WS provided a firstSlot (cheaper and more reliable for timestamps)",
          "pattern": "rpc_helius"
        },
        {
          "line": 1632,
          "snippet": "const r = await heliusGetSignaturesFast(mint, heliusUrl, 4000, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1632,
          "snippet": "const r = await heliusGetSignaturesFast(mint, heliusUrl, 4000, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1637,
          "snippet": "// compute earliest blockTime across signatures (Helius returns newest-first)",
          "pattern": "rpc_helius"
        },
        {
          "line": 1638,
          "snippet": "// compute earliest blockTime across signatures (Helius returns newest-first)",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function handleNewMintEventCached(mintOrObj: any, ttlSec?: number) {",
      "hits": [
        {
          "line": 1944,
          "snippet": "try { const t = await import('./utils/trace'); t.traceFlow('fastTokenFetcher:handleNewMintEventCached:cache_miss',{ mint, key, ttl }); } catch(e){}",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 1937,
          "snippet": "const ttl = Number(ttlSec ?? process.env.HELIUS_HANDLE_CACHE_TTL_S ?? 60);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function testFetchEnrichFilterLatest() {",
      "hits": [
        {
          "line": 2412,
          "snippet": "const subs = await fetchLatest5FromAllSources(limit);",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 2423,
          "snippet": "try { const ff = require('./fastTokenFetcher'); hf = ff && (ff.handleNewMintEvent || ff.default && ff.default.handleNewMintEvent); } catch(e) {}",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 2425,
          "snippet": "// fallback: use enrichTokenTimestamps on single token objects (guarded)",
          "pattern": "enrich"
        },
        {
          "line": 2426,
          "snippet": "const { enrichTokenTimestamps } = require('./utils/tokenUtils');",
          "pattern": "enrich"
        },
        {
          "line": 2432,
          "snippet": "if (allowEnrichment()) await enrichTokenTimestamps([token], { batchSize: 1, delayMs: 0 });",
          "pattern": "enrich"
        },
        {
          "line": 2413,
          "snippet": "const mints: string[] = Array.from(new Set([...(subs.heliusEvents || []), ...(subs.dexTop || []), ...(subs.heliusHistory || [])])).slice(0, limit);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2413,
          "snippet": "const mints: string[] = Array.from(new Set([...(subs.heliusEvents || []), ...(subs.dexTop || []), ...(subs.heliusHistory || [])])).slice(0, limit);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2416,
          "snippet": "const { createEnrichmentManager } = require('./heliusEnrichmentQueue');",
          "pattern": "rpc_helius"
        },
        {
          "line": 2413,
          "snippet": "const mints: string[] = Array.from(new Set([...(subs.heliusEvents || []), ...(subs.dexTop || []), ...(subs.heliusHistory || [])])).slice(0, limit);",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function worker() {",
      "hits": [
        {
          "line": 819,
          "snippet": "// Gate expensive officialEnrich calls by a lightweight on-chain activity check",
          "pattern": "enrich"
        },
        {
          "line": 832,
          "snippet": "// run officialEnrich under limiter + timeout and attach __meta",
          "pattern": "enrich"
        },
        {
          "line": 833,
          "snippet": "const host = 'officialEnrich';",
          "pattern": "enrich"
        },
        {
          "line": 837,
          "snippet": "// Respect collector-only guard: skip heavy officialEnrich unless enabled",
          "pattern": "enrich"
        },
        {
          "line": 843,
          "snippet": "const wrap = await withTimeout(officialEnrich(t, { amountUsd: Number(strat.buyAmount) || 50, timeoutMs: 4000 }), 4500);",
          "pattern": "enrich"
        },
        {
          "line": 847,
          "snippet": "t.__sources.push(makeSourceMeta('officialEnrich', true, { latencyMs: Date.now() - startE }));",
          "pattern": "enrich"
        },
        {
          "line": 850,
          "snippet": "t.__sources.push(makeSourceMeta('officialEnrich', false, { error: (ee && ee.message) || String(ee), latencyMs: Date.now() - startE }));",
          "pattern": "enrich"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function getUnifiedCandidates(limit: number) {",
      "hits": [
        {
          "line": 459,
          "snippet": "// 1) Helius WS buffer + recent events",
          "pattern": "rpc_helius"
        },
        {
          "line": 461,
          "snippet": "const { getRecentHeliusEvents } = require('./heliusWsListener');",
          "pattern": "rpc_helius"
        },
        {
          "line": 461,
          "snippet": "const { getRecentHeliusEvents } = require('./heliusWsListener');",
          "pattern": "rpc_helius"
        },
        {
          "line": 462,
          "snippet": "const evs = getRecentHeliusEvents();",
          "pattern": "rpc_helius"
        },
        {
          "line": 476,
          "snippet": "// attach structured provenance so Helius contributes to __sources in canonical cache",
          "pattern": "rpc_helius"
        },
        {
          "line": 478,
          "snippet": "const meta = makeSourceMeta('helius-ws', true, { raw: e });",
          "pattern": "rpc_helius"
        },
        {
          "line": 479,
          "snippet": "candidates.push({ mint: m, __sources: [meta], sourceTags: ['helius-ws'] });",
          "pattern": "rpc_helius"
        },
        {
          "line": 490,
          "snippet": "// 2) DexScreener boosts",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 461,
          "snippet": "const { getRecentHeliusEvents } = require('./heliusWsListener');",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function runDeepCacheCheck(opts?: { windowMin?: number; limit?: number }) {",
      "hits": [
        {
          "line": 1013,
          "snippet": "try { const sigs = await heliusGetSignaturesFast(item.addr, process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL || '', 4000, Number(process.env.HELIUS_RETRIES || 0)); console.log('signatures:', Array.isArray(sigs) ? `count=${sigs.length}` : safeStringSnippet(sigs, 200)); } catch (e) { console.log('sigs err', String(e)); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1013,
          "snippet": "try { const sigs = await heliusGetSignaturesFast(item.addr, process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL || '', 4000, Number(process.env.HELIUS_RETRIES || 0)); console.log('signatures:', Array.isArray(sigs) ? `count=${sigs.length}` : safeStringSnippet(sigs, 200)); } catch (e) { console.log('sigs err', String(e)); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1013,
          "snippet": "try { const sigs = await heliusGetSignaturesFast(item.addr, process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL || '', 4000, Number(process.env.HELIUS_RETRIES || 0)); console.log('signatures:', Array.isArray(sigs) ? `count=${sigs.length}` : safeStringSnippet(sigs, 200)); } catch (e) { console.log('sigs err', String(e)); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1013,
          "snippet": "try { const sigs = await heliusGetSignaturesFast(item.addr, process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL || '', 4000, Number(process.env.HELIUS_RETRIES || 0)); console.log('signatures:', Array.isArray(sigs) ? `count=${sigs.length}` : safeStringSnippet(sigs, 200)); } catch (e) { console.log('sigs err', String(e)); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1018,
          "snippet": "// Start Helius WS listener for durationMs milliseconds, then run getAccountInfo/helius signatures for captured events",
          "pattern": "rpc_helius"
        },
        {
          "line": 1018,
          "snippet": "// Start Helius WS listener for durationMs milliseconds, then run getAccountInfo/helius signatures for captured events",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function captureHeliusAndVerify(durationMs = 60000) {",
      "hits": [
        {
          "line": 1019,
          "snippet": "export async function captureHeliusAndVerify(durationMs = 60000) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 1021,
          "snippet": "const wsMod = require('./heliusWsListener');",
          "pattern": "rpc_helius"
        },
        {
          "line": 1022,
          "snippet": "console.log('Starting Helius WS listener for', durationMs, 'ms...');",
          "pattern": "rpc_helius"
        },
        {
          "line": 1023,
          "snippet": "const inst = await (wsMod.startHeliusWebsocketListener ? wsMod.startHeliusWebsocketListener({ onOpen: () => console.log('WS open'), onMessage: () => {}, onClose: () => console.log('WS closed'), onError: (e: any) => console.warn('WS error', e && e.message) }) : null);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1023,
          "snippet": "const inst = await (wsMod.startHeliusWebsocketListener ? wsMod.startHeliusWebsocketListener({ onOpen: () => console.log('WS open'), onMessage: () => {}, onClose: () => console.log('WS closed'), onError: (e: any) => console.warn('WS error', e && e.message) }) : null);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1025,
          "snippet": "const ev = wsMod.getRecentHeliusEvents ? wsMod.getRecentHeliusEvents() : [];",
          "pattern": "rpc_helius"
        },
        {
          "line": 1025,
          "snippet": "const ev = wsMod.getRecentHeliusEvents ? wsMod.getRecentHeliusEvents() : [];",
          "pattern": "rpc_helius"
        },
        {
          "line": 1034,
          "snippet": "try { const sigs = await heliusGetSignaturesFast(mint, process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL || '', 4000, Number(process.env.HELIUS_RETRIES || 1)); if (!sigs) console.log('signatures: null'); else if (Array.isArray(sigs)) console.log('signatures count:', sigs.length, 'sample0:', safeStringSnippet(sigs[0], 200)); else if (sigs.result && Array.isArray(sigs.result)) console.log('signatures count:', sigs.result.length, 'sample0:', safeStringSnippet(sigs.result[0], 200)); else console.log('signatures:', safeStringSnippet(sigs, 200)); } catch (err) { console.log('sigs.err', String(err)); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1034,
          "snippet": "try { const sigs = await heliusGetSignaturesFast(mint, process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL || '', 4000, Number(process.env.HELIUS_RETRIES || 1)); if (!sigs) console.log('signatures: null'); else if (Array.isArray(sigs)) console.log('signatures count:', sigs.length, 'sample0:', safeStringSnippet(sigs[0], 200)); else if (sigs.result && Array.isArray(sigs.result)) console.log('signatures count:', sigs.result.length, 'sample0:', safeStringSnippet(sigs.result[0], 200)); else console.log('signatures:', safeStringSnippet(sigs, 200)); } catch (err) { console.log('sigs.err', String(err)); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1034,
          "snippet": "try { const sigs = await heliusGetSignaturesFast(mint, process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL || '', 4000, Number(process.env.HELIUS_RETRIES || 1)); if (!sigs) console.log('signatures: null'); else if (Array.isArray(sigs)) console.log('signatures count:', sigs.length, 'sample0:', safeStringSnippet(sigs[0], 200)); else if (sigs.result && Array.isArray(sigs.result)) console.log('signatures count:', sigs.result.length, 'sample0:', safeStringSnippet(sigs.result[0], 200)); else console.log('signatures:', safeStringSnippet(sigs, 200)); } catch (err) { console.log('sigs.err', String(err)); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1034,
          "snippet": "try { const sigs = await heliusGetSignaturesFast(mint, process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL || '', 4000, Number(process.env.HELIUS_RETRIES || 1)); if (!sigs) console.log('signatures: null'); else if (Array.isArray(sigs)) console.log('signatures count:', sigs.length, 'sample0:', safeStringSnippet(sigs[0], 200)); else if (sigs.result && Array.isArray(sigs.result)) console.log('signatures count:', sigs.result.length, 'sample0:', safeStringSnippet(sigs.result[0], 200)); else console.log('signatures:', safeStringSnippet(sigs, 200)); } catch (err) { console.log('sigs.err', String(err)); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1038,
          "snippet": "} catch (e) { console.error('captureHeliusAndVerify err', e && e.message ? e.message : e); }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1042,
          "snippet": "// Quick CLI: fast discovery + Helius_FAST enrichment",
          "pattern": "rpc_helius"
        },
        {
          "line": 1021,
          "snippet": "const wsMod = require('./heliusWsListener');",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function mintPreviouslySeen(mint: string, txBlockTime: number | null, currentSig?: string): Promise<boolean | null> {",
      "hits": [
        {
          "line": 1212,
          "snippet": "const heliusUrl = process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1212,
          "snippet": "const heliusUrl = process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1212,
          "snippet": "const heliusUrl = process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1213,
          "snippet": "if (!heliusUrl) return null;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1226,
          "snippet": "const lookback = Number(process.env.HELIUS_MINT_PREV_LOOKBACK || 20);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1227,
          "snippet": "const res = await heliusGetSignaturesFast(mint, heliusUrl, 4000, 0).catch(() => null);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1227,
          "snippet": "const res = await heliusGetSignaturesFast(mint, heliusUrl, 4000, 0).catch(() => null);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1220,
          "snippet": "const v = await rc.get(key).catch(() => null);",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function getAccountInfo(pubkey: string) {",
      "hits": [
        {
          "line": 1580,
          "snippet": "(globalThis as any).__heliusAccountCache = (globalThis as any).__heliusAccountCache || new TTLCache<string, any>(Number(process.env.HELIUS_ACCOUNT_CACHE_MS || 30_000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1580,
          "snippet": "(globalThis as any).__heliusAccountCache = (globalThis as any).__heliusAccountCache || new TTLCache<string, any>(Number(process.env.HELIUS_ACCOUNT_CACHE_MS || 30_000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1580,
          "snippet": "(globalThis as any).__heliusAccountCache = (globalThis as any).__heliusAccountCache || new TTLCache<string, any>(Number(process.env.HELIUS_ACCOUNT_CACHE_MS || 30_000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 1581,
          "snippet": "const cache: TTLCache<string, any> = (globalThis as any).__heliusAccountCache;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1585,
          "snippet": "const res = await heliusRpc('getAccountInfo', [pubkey, { encoding: 'base64' }], 4000, 1);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1586,
          "snippet": "try { cache.set(key, res, Number(process.env.HELIUS_ACCOUNT_CACHE_MS || 30_000)); } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 1589,
          "snippet": "return heliusRpc('getAccountInfo', [pubkey, { encoding: 'base64' }], 4000, 1);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function getTokenSupply(pubkey: string) {",
      "hits": [
        {
          "line": 1594,
          "snippet": "return heliusRpc('getTokenSupply', [pubkey], 4000, 1);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export async function runFastDiscoveryCli(opts?: { topN?: number; timeoutMs?: number; concurrency?: number }) {",
      "hits": [
        {
          "line": 1995,
          "snippet": "const heliusUrl = process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1995,
          "snippet": "const heliusUrl = process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1995,
          "snippet": "const heliusUrl = process.env.HELIUS_FAST_RPC_URL || HELIUS_RPC_URL;",
          "pattern": "rpc_helius"
        },
        {
          "line": 2000,
          "snippet": "console.error('Failed to fetch DexScreener boosts (empty/timeout)');",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 2007,
          "snippet": "console.error('DexScreener returned no items');",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "function hostKey(u: string) {",
      "hits": [
        {
          "line": 2047,
          "snippet": "// Helper: page getSignaturesForAddress via heliusRpc to collect up to max signatures (for deep verification)",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function collectSignaturesFull(address: string, maxCollect = 2000) {",
      "hits": [
        {
          "line": 2056,
          "snippet": "const res = await heliusRpc('getSignaturesForAddress', params, 5000, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2069,
          "snippet": "if (!heliusUrl) { results.push({ mint: t.mint, error: 'no-helius-url' }); return; }",
          "pattern": "rpc_helius"
        },
        {
          "line": 2069,
          "snippet": "if (!heliusUrl) { results.push({ mint: t.mint, error: 'no-helius-url' }); return; }",
          "pattern": "rpc_helius"
        },
        {
          "line": 2070,
          "snippet": "const hk = hostKey(heliusUrl);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2083,
          "snippet": "else r = await heliusGetSignaturesFast(t.mint, heliusUrl, timeoutMs, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2083,
          "snippet": "else r = await heliusGetSignaturesFast(t.mint, heliusUrl, timeoutMs, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2085,
          "snippet": "r = await heliusGetSignaturesFast(t.mint, heliusUrl, timeoutMs, 0);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2085,
          "snippet": "r = await heliusGetSignaturesFast(t.mint, heliusUrl, timeoutMs, 0);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function maybeValidate(list: string[]) {",
      "hits": [
        {
          "line": 2386,
          "snippet": "const concurrency = Number(process.env.HELIUS_VALIDATE_CONCURRENCY || 3);",
          "pattern": "rpc_helius"
        },
        {
          "line": 2397,
          "snippet": "const heliusEventsNorm = Array.from(new Set(heliusEvents)).map(x=>normalizeMintCandidate(x)).filter(Boolean) as string[];",
          "pattern": "rpc_helius"
        },
        {
          "line": 2397,
          "snippet": "const heliusEventsNorm = Array.from(new Set(heliusEvents)).map(x=>normalizeMintCandidate(x)).filter(Boolean) as string[];",
          "pattern": "rpc_helius"
        },
        {
          "line": 2398,
          "snippet": "const heliusHistoryNorm = Array.from(new Set(heliusHistory)).map(x=>normalizeMintCandidate(x)).filter(Boolean) as string[];",
          "pattern": "rpc_helius"
        },
        {
          "line": 2398,
          "snippet": "const heliusHistoryNorm = Array.from(new Set(heliusHistory)).map(x=>normalizeMintCandidate(x)).filter(Boolean) as string[];",
          "pattern": "rpc_helius"
        },
        {
          "line": 2401,
          "snippet": "heliusEvents: await maybeValidate(heliusEventsNorm),",
          "pattern": "rpc_helius"
        },
        {
          "line": 2401,
          "snippet": "heliusEvents: await maybeValidate(heliusEventsNorm),",
          "pattern": "rpc_helius"
        },
        {
          "line": 2403,
          "snippet": "heliusHistory: await maybeValidate(heliusHistoryNorm),",
          "pattern": "rpc_helius"
        },
        {
          "line": 2403,
          "snippet": "heliusHistory: await maybeValidate(heliusHistoryNorm),",
          "pattern": "rpc_helius"
        },
        {
          "line": 2402,
          "snippet": "dexTop: dex.slice(0, n),",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function getRedisClient() {",
      "hits": [
        {
          "line": 60,
          "snippet": "if (__redisClient) return __redisClient;",
          "pattern": "redis"
        },
        {
          "line": 60,
          "snippet": "if (__redisClient) return __redisClient;",
          "pattern": "redis"
        },
        {
          "line": 64,
          "snippet": "// (createClient() with no url will try localhost and may block if Redis is not available).",
          "pattern": "redis"
        },
        {
          "line": 66,
          "snippet": "const client = createClient({ url });",
          "pattern": "redis"
        },
        {
          "line": 69,
          "snippet": "__redisClient = client;",
          "pattern": "redis"
        },
        {
          "line": 70,
          "snippet": "return __redisClient;",
          "pattern": "redis"
        },
        {
          "line": 72,
          "snippet": "__redisClient = null;",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function getCachedBlockTimeForSlot(slot: number): Promise<number | null> {",
      "hits": [
        {
          "line": 1420,
          "snippet": "const v = await rc.get(key).catch(() => null);",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "async function markProcessedGlobal(key: string, ttlSec = 60) {",
      "hits": [
        {
          "line": 95,
          "snippet": "const DEXBOOSTS = process.env.DEXSCREENER_API_ENDPOINT || 'https://api.dexscreener.com/token-boosts/latest/v1';",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/fastTokenFetcher.ts",
      "func": "export function hashTokenAddress(addr: string) {",
      "hits": [
        {
          "line": 102,
          "snippet": "// (DexScreener / CoinGecko boosts) and avoid disk-based fallbacks for sent_tokens.",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/heliusEnrichmentQueue.ts",
      "func": "async function tryInitRedis() {",
      "hits": [
        {
          "line": 31,
          "snippet": "redisClient.on && redisClient.on('error', (e: any) => { try { console.warn('[heliusEnrichmentQueue] redis error', e && e.message ? e.message : e); } catch {} });",
          "pattern": "rpc_helius"
        },
        {
          "line": 40,
          "snippet": "try { console.log('[heliusEnrichmentQueue] connected to redis'); } catch {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 46,
          "snippet": "try { console.warn('[heliusEnrichmentQueue] failed to init redis, falling back to in-memory dedupe', e && e.message ? e.message : e); } catch {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 27,
          "snippet": "if (redisClient) return;",
          "pattern": "redis"
        },
        {
          "line": 29,
          "snippet": "const { createClient } = await import('redis');",
          "pattern": "redis"
        },
        {
          "line": 30,
          "snippet": "redisClient = createClient({ url: REDIS_URL });",
          "pattern": "redis"
        },
        {
          "line": 30,
          "snippet": "redisClient = createClient({ url: REDIS_URL });",
          "pattern": "redis"
        },
        {
          "line": 31,
          "snippet": "redisClient.on && redisClient.on('error', (e: any) => { try { console.warn('[heliusEnrichmentQueue] redis error', e && e.message ? e.message : e); } catch {} });",
          "pattern": "redis"
        },
        {
          "line": 31,
          "snippet": "redisClient.on && redisClient.on('error', (e: any) => { try { console.warn('[heliusEnrichmentQueue] redis error', e && e.message ? e.message : e); } catch {} });",
          "pattern": "redis"
        },
        {
          "line": 31,
          "snippet": "redisClient.on && redisClient.on('error', (e: any) => { try { console.warn('[heliusEnrichmentQueue] redis error', e && e.message ? e.message : e); } catch {} });",
          "pattern": "redis"
        },
        {
          "line": 33,
          "snippet": "const p = redisClient.connect();",
          "pattern": "redis"
        },
        {
          "line": 37,
          "snippet": "if (redisClient && typeof redisClient.isOpen !== 'undefined' ? redisClient.isOpen : true) {",
          "pattern": "redis"
        },
        {
          "line": 37,
          "snippet": "if (redisClient && typeof redisClient.isOpen !== 'undefined' ? redisClient.isOpen : true) {",
          "pattern": "redis"
        },
        {
          "line": 37,
          "snippet": "if (redisClient && typeof redisClient.isOpen !== 'undefined' ? redisClient.isOpen : true) {",
          "pattern": "redis"
        },
        {
          "line": 39,
          "snippet": "redisReady = true;",
          "pattern": "redis"
        },
        {
          "line": 40,
          "snippet": "try { console.log('[heliusEnrichmentQueue] connected to redis'); } catch {}",
          "pattern": "redis"
        },
        {
          "line": 43,
          "snippet": "redisClient = null; useRedis = false; redisReady = false;",
          "pattern": "redis"
        },
        {
          "line": 43,
          "snippet": "redisClient = null; useRedis = false; redisReady = false;",
          "pattern": "redis"
        },
        {
          "line": 46,
          "snippet": "try { console.warn('[heliusEnrichmentQueue] failed to init redis, falling back to in-memory dedupe', e && e.message ? e.message : e); } catch {}",
          "pattern": "redis"
        },
        {
          "line": 47,
          "snippet": "redisClient = null; useRedis = false; redisReady = false;",
          "pattern": "redis"
        },
        {
          "line": 47,
          "snippet": "redisClient = null; useRedis = false; redisReady = false;",
          "pattern": "redis"
        },
        {
          "line": 52,
          "snippet": "const _redisInitPromise = tryInitRedis();",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/heliusEnrichmentQueue.ts",
      "func": "async function redisTrySetDedup(key: string, ttlSecondsLocal: number) {",
      "hits": [
        {
          "line": 83,
          "snippet": "try { console.warn('[heliusEnrichmentQueue] redis set failed, disabling redis dedupe', e && e.message ? e.message : e); } catch {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 108,
          "snippet": "const key = `helius:enrich:${mint}`;",
          "pattern": "rpc_helius"
        },
        {
          "line": 74,
          "snippet": "async function redisTrySetDedup(key: string, ttlSecondsLocal: number) {",
          "pattern": "redis"
        },
        {
          "line": 75,
          "snippet": "// Wait a short time for redis readiness if initialization in progress",
          "pattern": "redis"
        },
        {
          "line": 76,
          "snippet": "try { await Promise.race([_redisInitPromise, new Promise(res => setTimeout(res, 800))]); } catch {}",
          "pattern": "redis"
        },
        {
          "line": 77,
          "snippet": "if (!redisClient || !useRedis || !redisReady) return false;",
          "pattern": "redis"
        },
        {
          "line": 77,
          "snippet": "if (!redisClient || !useRedis || !redisReady) return false;",
          "pattern": "redis"
        },
        {
          "line": 79,
          "snippet": "// Use SET NX EX (redis v4 client supports options)",
          "pattern": "redis"
        },
        {
          "line": 80,
          "snippet": "const res = await redisClient.set(key, '1', { NX: true, EX: ttlSecondsLocal });",
          "pattern": "redis"
        },
        {
          "line": 83,
          "snippet": "try { console.warn('[heliusEnrichmentQueue] redis set failed, disabling redis dedupe', e && e.message ? e.message : e); } catch {}",
          "pattern": "redis"
        },
        {
          "line": 83,
          "snippet": "try { console.warn('[heliusEnrichmentQueue] redis set failed, disabling redis dedupe', e && e.message ? e.message : e); } catch {}",
          "pattern": "redis"
        },
        {
          "line": 84,
          "snippet": "try { redisClient.disconnect && redisClient.disconnect().catch(() => {}); } catch {}",
          "pattern": "redis"
        },
        {
          "line": 84,
          "snippet": "try { redisClient.disconnect && redisClient.disconnect().catch(() => {}); } catch {}",
          "pattern": "redis"
        },
        {
          "line": 85,
          "snippet": "redisClient = null;",
          "pattern": "redis"
        },
        {
          "line": 87,
          "snippet": "redisReady = false;",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/heliusEnrichmentQueue.ts",
      "func": "export function createEnrichmentManager(opts?: { ttlSeconds?: number; maxConcurrent?: number }) {",
      "hits": [
        {
          "line": 19,
          "snippet": "let redisClient: any = null;",
          "pattern": "redis"
        },
        {
          "line": 21,
          "snippet": "let redisReady = false;",
          "pattern": "redis"
        },
        {
          "line": 24,
          "snippet": "// init redis but ensure the manager waits a short bounded time for readiness to avoid races",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/heliusEnrichmentQueue.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 114,
          "snippet": "const ok = await redisTrySetDedup(key, ttlSeconds);",
          "pattern": "redis"
        },
        {
          "line": 116,
          "snippet": "try { console.log('Enrichment skipped (redis dedupe) for', mint); } catch {}",
          "pattern": "redis"
        },
        {
          "line": 117,
          "snippet": "resolve({ skipped: true, reason: 'redis-dedupe' });",
          "pattern": "redis"
        },
        {
          "line": 125,
          "snippet": "// fallback to in-memory dedupe on redis errors",
          "pattern": "redis"
        },
        {
          "line": 159,
          "snippet": "redis: { enabled: !!REDIS_URL, connected: !!redisClient }",
          "pattern": "redis"
        },
        {
          "line": 159,
          "snippet": "redis: { enabled: !!REDIS_URL, connected: !!redisClient }",
          "pattern": "redis"
        },
        {
          "line": 162,
          "snippet": "// Expose raw redis client for advanced ops (optional)",
          "pattern": "redis"
        },
        {
          "line": 163,
          "snippet": "_redisClient: () => redisClient,",
          "pattern": "redis"
        },
        {
          "line": 163,
          "snippet": "_redisClient: () => redisClient,",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "async function httpGetWithRetry(url: string, opts: any = {}) {",
      "hits": [
        {
          "line": 122,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 122,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 127,
          "snippet": "const res = await axios.get(url, { timeout: Number(opts.timeoutMs || 2000) });",
          "pattern": "axios"
        },
        {
          "line": 144,
          "snippet": "// Retry wrapper for tokenUtils.officialEnrich to handle transient Helius 429s",
          "pattern": "enrich"
        },
        {
          "line": 123,
          "snippet": "const maxAttempts = Number(process.env.HELIUS_HTTP_RETRY_COUNT ?? 3);",
          "pattern": "rpc_helius"
        },
        {
          "line": 124,
          "snippet": "const baseMs = Number(process.env.HELIUS_HTTP_RETRY_BASE_MS ?? 300);",
          "pattern": "rpc_helius"
        },
        {
          "line": 144,
          "snippet": "// Retry wrapper for tokenUtils.officialEnrich to handle transient Helius 429s",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "async function quickIsTraded(mintAddr: string) {",
      "hits": [
        {
          "line": 185,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 185,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 205,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 205,
          "snippet": "const axios = require('axios');",
          "pattern": "axios"
        },
        {
          "line": 200,
          "snippet": "// 2) Fallback: Helius parse-history for tokenTransfers/nativeTransfers within freshness window",
          "pattern": "rpc_helius"
        },
        {
          "line": 203,
          "snippet": "const parseTemplate = process.env.HELIUS_PARSE_HISTORY_URL || cfg.HELIUS_PARSE_HISTORY_URL || 'https://api.helius.xyz/v0/addresses/{address}/transactions/?api-key=' + (process.env.HELIUS_API_KEY || '');",
          "pattern": "rpc_helius"
        },
        {
          "line": 203,
          "snippet": "const parseTemplate = process.env.HELIUS_PARSE_HISTORY_URL || cfg.HELIUS_PARSE_HISTORY_URL || 'https://api.helius.xyz/v0/addresses/{address}/transactions/?api-key=' + (process.env.HELIUS_API_KEY || '');",
          "pattern": "rpc_helius"
        },
        {
          "line": 203,
          "snippet": "const parseTemplate = process.env.HELIUS_PARSE_HISTORY_URL || cfg.HELIUS_PARSE_HISTORY_URL || 'https://api.helius.xyz/v0/addresses/{address}/transactions/?api-key=' + (process.env.HELIUS_API_KEY || '');",
          "pattern": "rpc_helius"
        },
        {
          "line": 203,
          "snippet": "const parseTemplate = process.env.HELIUS_PARSE_HISTORY_URL || cfg.HELIUS_PARSE_HISTORY_URL || 'https://api.helius.xyz/v0/addresses/{address}/transactions/?api-key=' + (process.env.HELIUS_API_KEY || '');",
          "pattern": "rpc_helius"
        },
        {
          "line": 206,
          "snippet": "const resp = await httpGetWithRetry(url, { timeoutMs: Number(process.env.HELIUS_QUICK_HTTP_TIMEOUT_MS || 1800) }).catch(() => null);",
          "pattern": "rpc_helius"
        },
        {
          "line": 211,
          "snippet": "if (bt && (nowS - Number(bt) <= HELIUS_FRESHNESS_THRESHOLD_S)) return true;",
          "pattern": "rpc_helius"
        },
        {
          "line": 189,
          "snippet": "const dTpl = process.env.DEXSCREENER_API_ENDPOINT_TOKEN_PAIRS || 'https://api.dexscreener.com/token-pairs/v1/solana/So11111111111111111111111111111111111111112';",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 193,
          "snippet": "// dexscreener returns object with pairs; if any pairs exist, it's trading",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 4,
          "snippet": "// optional blockTime lookup helpers from fastTokenFetcher",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 8,
          "snippet": "const ft = require('./fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 483,
          "snippet": "const ff = require('./fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 518,
          "snippet": "const ff = require('./fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 530,
          "snippet": "// If enrichment retrieved useful fields, persist snapshot via fastTokenFetcher if available",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 719,
          "snippet": "const ftf = require('./fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 809,
          "snippet": "const ff = require('./fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 816,
          "snippet": "try { const tmod = await import('./utils/trace'); tmod.traceFlow('heliusWsListener:enrichment_enqueued',{ mint: evt.mint || null, handler: hf ? 'fastTokenFetcher.handleNewMintEvent' : 'none' }); } catch(e){}",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 819,
          "snippet": "const ftf = require('./fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 515,
          "snippet": "// If cache hints liquidity/volume, schedule a non-blocking quick officialEnrich for this mint",
          "pattern": "enrich"
        },
        {
          "line": 528,
          "snippet": "// run officialEnrich with retry/backoff wrapper",
          "pattern": "enrich"
        },
        {
          "line": 1,
          "snippet": "// Minimal safe Helius WebSocket listener.",
          "pattern": "rpc_helius"
        },
        {
          "line": 3,
          "snippet": "import { HELIUS_USE_WEBSOCKET, getHeliusWebsocketUrl, HELIUS_SUBSCRIBE_METADATA, HELIUS_SUBSCRIBE_SPLTOKEN } from './config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 3,
          "snippet": "import { HELIUS_USE_WEBSOCKET, getHeliusWebsocketUrl, HELIUS_SUBSCRIBE_METADATA, HELIUS_SUBSCRIBE_SPLTOKEN } from './config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 3,
          "snippet": "import { HELIUS_USE_WEBSOCKET, getHeliusWebsocketUrl, HELIUS_SUBSCRIBE_METADATA, HELIUS_SUBSCRIBE_SPLTOKEN } from './config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 3,
          "snippet": "import { HELIUS_USE_WEBSOCKET, getHeliusWebsocketUrl, HELIUS_SUBSCRIBE_METADATA, HELIUS_SUBSCRIBE_SPLTOKEN } from './config';",
          "pattern": "rpc_helius"
        },
        {
          "line": 309,
          "snippet": "// Set env HELIUS_ENRICH_SCORE_THRESHOLD to override (e.g. 0.05 for permissive).",
          "pattern": "rpc_helius"
        },
        {
          "line": 310,
          "snippet": "const HELIUS_ENRICH_SCORE_THRESHOLD = Number(process.env.HELIUS_ENRICH_SCORE_THRESHOLD ?? 0.05);",
          "pattern": "rpc_helius"
        },
        {
          "line": 310,
          "snippet": "const HELIUS_ENRICH_SCORE_THRESHOLD = Number(process.env.HELIUS_ENRICH_SCORE_THRESHOLD ?? 0.05);",
          "pattern": "rpc_helius"
        },
        {
          "line": 312,
          "snippet": "const HELIUS_KNOWN_PROGRAM_IDS = new Set([",
          "pattern": "rpc_helius"
        },
        {
          "line": 324,
          "snippet": "const _heliusListenerStats: Record<string, number> = {",
          "pattern": "rpc_helius"
        },
        {
          "line": 443,
          "snippet": "const evt = analyzeHeliusMessage(parsed);",
          "pattern": "rpc_helius"
        },
        {
          "line": 445,
          "snippet": "try { const tmod = await import('./utils/trace'); tmod.traceFlow('heliusWsListener:event_received',{ mint: evt.mint || null, kind: evt.eventType || null, rawSummary: !!(parsed && parsed.params && parsed.params.result && parsed.params.result.value), signature: parsed?.params?.result?.value?.signature ?? parsed?.result?.value?.signature ?? null }); } catch(e){}",
          "pattern": "rpc_helius"
        },
        {
          "line": 462,
          "snippet": "const VERBOSE = !!process.env.HELIUS_VERBOSE;",
          "pattern": "rpc_helius"
        },
        {
          "line": 470,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 470,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 478,
          "snippet": "_heliusListenerStats.processed = (_heliusListenerStats.processed || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 478,
          "snippet": "_heliusListenerStats.processed = (_heliusListenerStats.processed || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 480,
          "snippet": "if (typeof score !== 'number' || Number.isNaN(score) || score < HELIUS_ENRICH_SCORE_THRESHOLD) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 510,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 510,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 511,
          "snippet": "try { if ((_heliusListenerStats.skippedLowConfidence || 0) % 50 === 1) console.log('Skipping memo-only event (no postTokenBalances)', evt.mint || '(no-mint)'); } catch {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 524,
          "snippet": "_heliusListenerStats.bgMintInFlight = (_heliusListenerStats.bgMintInFlight || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 524,
          "snippet": "_heliusListenerStats.bgMintInFlight = (_heliusListenerStats.bgMintInFlight || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 529,
          "snippet": "await retryOfficialEnrich(tuMod, tokenObj, { timeoutMs: Number(process.env.HELIUS_QUICK_OFFICIAL_ENRICH_TIMEOUT_MS || 2000) }).catch(() => null);",
          "pattern": "rpc_helius"
        },
        {
          "line": 542,
          "snippet": "if (VERBOSE) console.log(JSON.stringify({ helius_quick_enrich_followup: follow }));",
          "pattern": "rpc_helius"
        },
        {
          "line": 544,
          "snippet": "_heliusListenerStats.bgMintResolved = (_heliusListenerStats.bgMintResolved || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 544,
          "snippet": "_heliusListenerStats.bgMintResolved = (_heliusListenerStats.bgMintResolved || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 546,
          "snippet": "_heliusListenerStats.bgMintNull = (_heliusListenerStats.bgMintNull || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 546,
          "snippet": "_heliusListenerStats.bgMintNull = (_heliusListenerStats.bgMintNull || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 549,
          "snippet": "_heliusListenerStats.bgMintFailed = (_heliusListenerStats.bgMintFailed || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 549,
          "snippet": "_heliusListenerStats.bgMintFailed = (_heliusListenerStats.bgMintFailed || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 552,
          "snippet": "try { _heliusListenerStats.bgMintInFlight = Math.max(0, (_heliusListenerStats.bgMintInFlight || 1) - 1); } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 552,
          "snippet": "try { _heliusListenerStats.bgMintInFlight = Math.max(0, (_heliusListenerStats.bgMintInFlight || 1) - 1); } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 556,
          "snippet": "_heliusListenerStats.bgMintSkippedDueToDedupe = (_heliusListenerStats.bgMintSkippedDueToDedupe || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 556,
          "snippet": "_heliusListenerStats.bgMintSkippedDueToDedupe = (_heliusListenerStats.bgMintSkippedDueToDedupe || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 560,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 560,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 561,
          "snippet": "try { if ((_heliusListenerStats.skippedLowConfidence || 0) % 10 === 1) console.log('Skipping enrichment due to low confidence (sampled)', evt.mint || '(no-mint)', 'score=', typeof score === 'number' && score.toFixed ? score.toFixed(2) : score); } catch {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 572,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 572,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 573,
          "snippet": "try { if ((_heliusListenerStats.skippedLowConfidence || 0) % 50 === 1) console.log('Skipping low-confidence event: tx does not show token activity', evt.mint || '(no-mint)', 'eventType=', evt.eventType); } catch {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 581,
          "snippet": "if (HELIUS_REQUIRE_DEXSCREENER) isTraded = await quickIsTradedByDex(mintAddr);",
          "pattern": "rpc_helius"
        },
        {
          "line": 589,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 589,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 590,
          "snippet": "try { if ((_heliusListenerStats.skippedLowConfidence || 0) % 50 === 1) console.log('Skipping enrichment due to low confidence (not traded/too-old)', evt.mint || '(no-mint)', 'score=', typeof score === 'number' && score.toFixed ? score.toFixed(2) : score); } catch {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 595,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 595,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 601,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 601,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 626,
          "snippet": "_heliusListenerStats.cacheHit = (_heliusListenerStats.cacheHit || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 626,
          "snippet": "_heliusListenerStats.cacheHit = (_heliusListenerStats.cacheHit || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 631,
          "snippet": "_heliusListenerStats.cacheMiss = (_heliusListenerStats.cacheMiss || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 631,
          "snippet": "_heliusListenerStats.cacheMiss = (_heliusListenerStats.cacheMiss || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 642,
          "snippet": "const ALLOW_SYNC = String(process.env.HELIUS_QUICK_SYNC_BLOCKTIME ?? 'true').toLowerCase() !== 'false';",
          "pattern": "rpc_helius"
        },
        {
          "line": 643,
          "snippet": "const SYNC_TIMEOUT_MS = Number(process.env.HELIUS_QUICK_SYNC_TIMEOUT_MS ?? 1200);",
          "pattern": "rpc_helius"
        },
        {
          "line": 655,
          "snippet": "_heliusListenerStats.bgResolved = (_heliusListenerStats.bgResolved || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 655,
          "snippet": "_heliusListenerStats.bgResolved = (_heliusListenerStats.bgResolved || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 675,
          "snippet": "_heliusListenerStats.bgInFlight = (_heliusListenerStats.bgInFlight || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 675,
          "snippet": "_heliusListenerStats.bgInFlight = (_heliusListenerStats.bgInFlight || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 682,
          "snippet": "_heliusListenerStats.bgResolved = (_heliusListenerStats.bgResolved || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 682,
          "snippet": "_heliusListenerStats.bgResolved = (_heliusListenerStats.bgResolved || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 693,
          "snippet": "try { if (VERBOSE) console.log('helius_quick_enrich_followup:', evt.mint || '(no-mint)', 'slot=', slotNum, 'blockTime=', bt, 'diag=', JSON.stringify((follow as any)._diag)); } catch {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 694,
          "snippet": "if (VERBOSE) console.log(JSON.stringify({ helius_quick_enrich_followup: follow }));",
          "pattern": "rpc_helius"
        },
        {
          "line": 696,
          "snippet": "_heliusListenerStats.bgNull = (_heliusListenerStats.bgNull || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 696,
          "snippet": "_heliusListenerStats.bgNull = (_heliusListenerStats.bgNull || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 698,
          "snippet": "try { if (VERBOSE) console.log('helius_quick_enrich_followup:', evt.mint || '(no-mint)', 'slot=', slotNum, 'blockTime= null', 'diag=', JSON.stringify((follow as any)._diag)); } catch {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 699,
          "snippet": "if (VERBOSE) console.log(JSON.stringify({ helius_quick_enrich_followup: follow }));",
          "pattern": "rpc_helius"
        },
        {
          "line": 705,
          "snippet": "try { _heliusListenerStats.bgInFlight = Math.max(0, (_heliusListenerStats.bgInFlight || 1) - 1); } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 705,
          "snippet": "try { _heliusListenerStats.bgInFlight = Math.max(0, (_heliusListenerStats.bgInFlight || 1) - 1); } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 709,
          "snippet": "_heliusListenerStats.bgSkippedDueToDedupe = (_heliusListenerStats.bgSkippedDueToDedupe || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 709,
          "snippet": "_heliusListenerStats.bgSkippedDueToDedupe = (_heliusListenerStats.bgSkippedDueToDedupe || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 761,
          "snippet": "const quickTs = await tu.getFirstOnchainTimestamp(evt.mint, { timeoutMs: Number(process.env.HELIUS_QUICK_ONCHAIN_TIMEOUT_MS ?? 900) }).catch(() => ({ ts: null }));",
          "pattern": "rpc_helius"
        },
        {
          "line": 777,
          "snippet": "const effectiveDedupe = HELIUS_MEASURE_MODE ? Number(process.env.HELIUS_MEASURE_DEDUPE_S ?? 5) : HELIUS_MINT_DEDUPE_S;",
          "pattern": "rpc_helius"
        },
        {
          "line": 777,
          "snippet": "const effectiveDedupe = HELIUS_MEASURE_MODE ? Number(process.env.HELIUS_MEASURE_DEDUPE_S ?? 5) : HELIUS_MINT_DEDUPE_S;",
          "pattern": "rpc_helius"
        },
        {
          "line": 777,
          "snippet": "const effectiveDedupe = HELIUS_MEASURE_MODE ? Number(process.env.HELIUS_MEASURE_DEDUPE_S ?? 5) : HELIUS_MINT_DEDUPE_S;",
          "pattern": "rpc_helius"
        },
        {
          "line": 788,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 788,
          "snippet": "_heliusListenerStats.skippedLowConfidence = (_heliusListenerStats.skippedLowConfidence || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 789,
          "snippet": "try { if ((_heliusListenerStats.skippedLowConfidence || 0) % 50 === 1) console.log('Skipping quick-enrich: missing blockTime and not traded/young', evt.mint || '(no-mint)'); } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 799,
          "snippet": "try { console.log('helius_quick_enrich:', evt.mint || '(no-mint)', 'slot=', slot, 'blockTime=', blockTime, diagShort); } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 800,
          "snippet": "console.log(JSON.stringify({ helius_quick_enrich: quick }));",
          "pattern": "rpc_helius"
        },
        {
          "line": 813,
          "snippet": "const mgrMod = require('./heliusEnrichmentQueue');",
          "pattern": "rpc_helius"
        },
        {
          "line": 816,
          "snippet": "try { const tmod = await import('./utils/trace'); tmod.traceFlow('heliusWsListener:enrichment_enqueued',{ mint: evt.mint || null, handler: hf ? 'fastTokenFetcher.handleNewMintEvent' : 'none' }); } catch(e){}",
          "pattern": "rpc_helius"
        },
        {
          "line": 842,
          "snippet": "_heliusListenerStats.enriched = (_heliusListenerStats.enriched || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 842,
          "snippet": "_heliusListenerStats.enriched = (_heliusListenerStats.enriched || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 857,
          "snippet": "} catch (e) { _heliusListenerStats.parseErrors = (_heliusListenerStats.parseErrors || 0) + 1; }",
          "pattern": "rpc_helius"
        },
        {
          "line": 857,
          "snippet": "} catch (e) { _heliusListenerStats.parseErrors = (_heliusListenerStats.parseErrors || 0) + 1; }",
          "pattern": "rpc_helius"
        },
        {
          "line": 859,
          "snippet": "_heliusListenerStats.parseErrors = (_heliusListenerStats.parseErrors || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 859,
          "snippet": "_heliusListenerStats.parseErrors = (_heliusListenerStats.parseErrors || 0) + 1;",
          "pattern": "rpc_helius"
        },
        {
          "line": 860,
          "snippet": "console.warn('Failed to parse Helius WS message', err);",
          "pattern": "rpc_helius"
        },
        {
          "line": 867,
          "snippet": "console.log('HELIUS WebSocket closed', code, reason?.toString());",
          "pattern": "rpc_helius"
        },
        {
          "line": 874,
          "snippet": "console.warn('HELIUS WebSocket error', err?.message || err);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1041,
          "snippet": "if (!HELIUS_KNOWN_PROGRAM_IDS.has(cand)) found.candidate = found.candidate || cand;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1051,
          "snippet": "const cand = m[0]; if (!HELIUS_KNOWN_PROGRAM_IDS.has(cand)) found.candidate = found.candidate || cand;",
          "pattern": "rpc_helius"
        },
        {
          "line": 445,
          "snippet": "try { const tmod = await import('./utils/trace'); tmod.traceFlow('heliusWsListener:event_received',{ mint: evt.mint || null, kind: evt.eventType || null, rawSummary: !!(parsed && parsed.params && parsed.params.result && parsed.params.result.value), signature: parsed?.params?.result?.value?.signature ?? parsed?.result?.value?.signature ?? null }); } catch(e){}",
          "pattern": "ws_listener"
        },
        {
          "line": 816,
          "snippet": "try { const tmod = await import('./utils/trace'); tmod.traceFlow('heliusWsListener:enrichment_enqueued',{ mint: evt.mint || null, handler: hf ? 'fastTokenFetcher.handleNewMintEvent' : 'none' }); } catch(e){}",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "function startSlotBlocktimeWarmer(opts?: { intervalMs?: number, lookbackSlots?: number }) {",
      "hits": [
        {
          "line": 26,
          "snippet": "// determine a recent tip slot from fastTokenFetcher if available, else skip",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 27,
          "snippet": "const ff = require('./fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "async function quickIsMintYoung(mintAddr: string, maxAgeSec = HELIUS_MAX_MINT_AGE_S) {",
      "hits": [
        {
          "line": 264,
          "snippet": "const ff = require('./fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 285,
          "snippet": "const ffLocal = require('./fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 254,
          "snippet": "async function quickIsMintYoung(mintAddr: string, maxAgeSec = HELIUS_MAX_MINT_AGE_S) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 286,
          "snippet": "const tmo = Number(process.env.HELIUS_QUICK_HANDLE_TIMEOUT_MS || 2500);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "async function retryOfficialEnrich(tuMod: any, tokenObj: any, opts: { timeoutMs?: number } = {}) {",
      "hits": [
        {
          "line": 153,
          "snippet": "if (!tuMod || typeof tuMod.officialEnrich !== 'function') return null;",
          "pattern": "enrich"
        },
        {
          "line": 155,
          "snippet": "tuMod.officialEnrich(tokenObj, { timeoutMs: Number(opts.timeoutMs || 2000) }),",
          "pattern": "enrich"
        },
        {
          "line": 158,
          "snippet": "// if officialEnrich ran without throwing, return tokenObj so caller can inspect fields",
          "pattern": "enrich"
        },
        {
          "line": 149,
          "snippet": "const maxAttempts = Number(process.env.HELIUS_OFFICIAL_ENRICH_RETRY_COUNT ?? 3);",
          "pattern": "rpc_helius"
        },
        {
          "line": 150,
          "snippet": "const baseMs = Number(process.env.HELIUS_OFFICIAL_ENRICH_RETRY_BASE_MS ?? 300);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "async function startHeliusWebsocketListener(options?: { onMessage?: (msg: any) => void; onOpen?: () => void; onClose?: () => void; onError?: (err: any) => void; }) {",
      "hits": [
        {
          "line": 373,
          "snippet": "// in-memory set to dedupe background per-mint officialEnrich resolutions",
          "pattern": "enrich"
        },
        {
          "line": 349,
          "snippet": "async function startHeliusWebsocketListener(options?: { onMessage?: (msg: any) => void; onOpen?: () => void; onClose?: () => void; onError?: (err: any) => void; }) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 351,
          "snippet": "console.log('HELIUS WebSocket disabled via HELIUS_USE_WEBSOCKET=false');",
          "pattern": "rpc_helius"
        },
        {
          "line": 351,
          "snippet": "console.log('HELIUS WebSocket disabled via HELIUS_USE_WEBSOCKET=false');",
          "pattern": "rpc_helius"
        },
        {
          "line": 355,
          "snippet": "if (!HELIUS_WS_URL) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 356,
          "snippet": "console.warn('HELIUS_WEBSOCKET_URL not set in .env; WebSocket listener will not start.');",
          "pattern": "rpc_helius"
        },
        {
          "line": 363,
          "snippet": "const ws = new WebSocket(HELIUS_WS_URL, {",
          "pattern": "rpc_helius"
        },
        {
          "line": 364,
          "snippet": "// no extra options; Helius typically accepts api-key in query string",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "function tsToMs(v: any): number | null {",
      "hits": [
        {
          "line": 65,
          "snippet": "const HELIUS_WS_URL = getHeliusWebsocketUrl();",
          "pattern": "rpc_helius"
        },
        {
          "line": 65,
          "snippet": "const HELIUS_WS_URL = getHeliusWebsocketUrl();",
          "pattern": "rpc_helius"
        },
        {
          "line": 66,
          "snippet": "const USE_WS = HELIUS_USE_WEBSOCKET;",
          "pattern": "rpc_helius"
        },
        {
          "line": 67,
          "snippet": "const SUBSCRIBE_METADATA = HELIUS_SUBSCRIBE_METADATA;",
          "pattern": "rpc_helius"
        },
        {
          "line": 68,
          "snippet": "const SUBSCRIBE_SPLTOKEN = HELIUS_SUBSCRIBE_SPLTOKEN;",
          "pattern": "rpc_helius"
        },
        {
          "line": 71,
          "snippet": "// or quick external checks (DexScreener/CoinGecko/etc). Controlled via env",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "export function getProtocolRules() { return PROTOCOL_RULES; }",
      "hits": [
        {
          "line": 103,
          "snippet": "// base confidence score is low. Tunable via env HELIUS_FRESHNESS_THRESHOLD_S",
          "pattern": "rpc_helius"
        },
        {
          "line": 104,
          "snippet": "const HELIUS_FRESHNESS_THRESHOLD_S = Number(process.env.HELIUS_FRESHNESS_THRESHOLD_S ?? 180);",
          "pattern": "rpc_helius"
        },
        {
          "line": 104,
          "snippet": "const HELIUS_FRESHNESS_THRESHOLD_S = Number(process.env.HELIUS_FRESHNESS_THRESHOLD_S ?? 180);",
          "pattern": "rpc_helius"
        },
        {
          "line": 105,
          "snippet": "// If true, only accept low-confidence events when Dexscreener reports pairs (no Helius fallback)",
          "pattern": "rpc_helius"
        },
        {
          "line": 106,
          "snippet": "const HELIUS_REQUIRE_DEXSCREENER = (String(process.env.HELIUS_REQUIRE_DEXSCREENER || 'false').toLowerCase() === 'true');",
          "pattern": "rpc_helius"
        },
        {
          "line": 106,
          "snippet": "const HELIUS_REQUIRE_DEXSCREENER = (String(process.env.HELIUS_REQUIRE_DEXSCREENER || 'false').toLowerCase() === 'true');",
          "pattern": "rpc_helius"
        },
        {
          "line": 108,
          "snippet": "const HELIUS_MAX_MINT_AGE_S = Number(process.env.HELIUS_MAX_MINT_AGE_S ?? 60);",
          "pattern": "rpc_helius"
        },
        {
          "line": 108,
          "snippet": "const HELIUS_MAX_MINT_AGE_S = Number(process.env.HELIUS_MAX_MINT_AGE_S ?? 60);",
          "pattern": "rpc_helius"
        },
        {
          "line": 111,
          "snippet": "const QUICK_CHECK_TTL_S = Number(process.env.HELIUS_QUICK_CHECK_TTL_S ?? 600); // 10 minutes default",
          "pattern": "rpc_helius"
        },
        {
          "line": 113,
          "snippet": "const HELIUS_MINT_DEDUPE_S = Number(process.env.HELIUS_MINT_DEDUPE_S ?? 60);",
          "pattern": "rpc_helius"
        },
        {
          "line": 113,
          "snippet": "const HELIUS_MINT_DEDUPE_S = Number(process.env.HELIUS_MINT_DEDUPE_S ?? 60);",
          "pattern": "rpc_helius"
        },
        {
          "line": 115,
          "snippet": "const HELIUS_MEASURE_MODE = String(process.env.HELIUS_MEASURE_MODE || 'false').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        },
        {
          "line": 115,
          "snippet": "const HELIUS_MEASURE_MODE = String(process.env.HELIUS_MEASURE_MODE || 'false').toLowerCase() === 'true';",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "export function getHeliusListenerStats() { try { return { ..._heliusListenerStats }; } catch { return null; } }",
      "hits": [
        {
          "line": 345,
          "snippet": "export function getHeliusListenerStats() { try { return { ..._heliusListenerStats }; } catch { return null; } }",
          "pattern": "rpc_helius"
        },
        {
          "line": 345,
          "snippet": "export function getHeliusListenerStats() { try { return { ..._heliusListenerStats }; } catch { return null; } }",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "export function resetHeliusListenerStats() { try { _heliusListenerStats.processed = 0; _heliusListenerStats.enriched = 0; _heliusListenerStats.skippedLowConfidence = 0; _heliusListenerStats.parseErrors = 0; } catch {} }",
      "hits": [
        {
          "line": 346,
          "snippet": "export function resetHeliusListenerStats() { try { _heliusListenerStats.processed = 0; _heliusListenerStats.enriched = 0; _heliusListenerStats.skippedLowConfidence = 0; _heliusListenerStats.parseErrors = 0; } catch {} }",
          "pattern": "rpc_helius"
        },
        {
          "line": 346,
          "snippet": "export function resetHeliusListenerStats() { try { _heliusListenerStats.processed = 0; _heliusListenerStats.enriched = 0; _heliusListenerStats.skippedLowConfidence = 0; _heliusListenerStats.parseErrors = 0; } catch {} }",
          "pattern": "rpc_helius"
        },
        {
          "line": 346,
          "snippet": "export function resetHeliusListenerStats() { try { _heliusListenerStats.processed = 0; _heliusListenerStats.enriched = 0; _heliusListenerStats.skippedLowConfidence = 0; _heliusListenerStats.parseErrors = 0; } catch {} }",
          "pattern": "rpc_helius"
        },
        {
          "line": 346,
          "snippet": "export function resetHeliusListenerStats() { try { _heliusListenerStats.processed = 0; _heliusListenerStats.enriched = 0; _heliusListenerStats.skippedLowConfidence = 0; _heliusListenerStats.parseErrors = 0; } catch {} }",
          "pattern": "rpc_helius"
        },
        {
          "line": 346,
          "snippet": "export function resetHeliusListenerStats() { try { _heliusListenerStats.processed = 0; _heliusListenerStats.enriched = 0; _heliusListenerStats.skippedLowConfidence = 0; _heliusListenerStats.parseErrors = 0; } catch {} }",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "function startDiagInterval() {",
      "hits": [
        {
          "line": 387,
          "snippet": "const verbose = !!process.env.HELIUS_VERBOSE;",
          "pattern": "rpc_helius"
        },
        {
          "line": 388,
          "snippet": "const interval = Number(process.env.HELIUS_DIAG_INTERVAL_MS || (verbose ? 15000 : 60000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 391,
          "snippet": "const s = { ..._heliusListenerStats };",
          "pattern": "rpc_helius"
        },
        {
          "line": 392,
          "snippet": "if (verbose) console.log('HELIUS-LISTENER-STATS:', JSON.stringify(s)); else if ((s.processed || 0) % 500 === 0) console.log('HELIUS-LISTENER-STATS summary:', JSON.stringify({ processed: s.processed, enriched: s.enriched, skippedLowConfidence: s.skippedLowConfidence }));",
          "pattern": "rpc_helius"
        },
        {
          "line": 392,
          "snippet": "if (verbose) console.log('HELIUS-LISTENER-STATS:', JSON.stringify(s)); else if ((s.processed || 0) % 500 === 0) console.log('HELIUS-LISTENER-STATS summary:', JSON.stringify({ processed: s.processed, enriched: s.enriched, skippedLowConfidence: s.skippedLowConfidence }));",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "function stopDiagInterval() { try { if (_diagInterval) { clearInterval(_diagInterval); _diagInterval = null; } } catch (e) {} }",
      "hits": [
        {
          "line": 401,
          "snippet": "console.log('HELIUS WebSocket connected');",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "const origStop = api => {};",
      "hits": [
        {
          "line": 903,
          "snippet": "export { startHeliusWebsocketListener };",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "function analyzeHeliusMessage(parsed: any) {",
      "hits": [
        {
          "line": 906,
          "snippet": "function analyzeHeliusMessage(parsed: any) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 908,
          "snippet": "// Helius WS may deliver messages under params.result or result",
          "pattern": "rpc_helius"
        },
        {
          "line": 921,
          "snippet": "// Helius logsNotification: inspect logs for explicit patterns and memo content",
          "pattern": "rpc_helius"
        },
        {
          "line": 942,
          "snippet": "// If Helius gives parsed inner instructions (meta.innerInstructions), search there first",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "function walk(o: any, depth = 0, parentKey?: string) {",
      "hits": [
        {
          "line": 1011,
          "snippet": "if (!HELIUS_KNOWN_PROGRAM_IDS.has(v2) && !deny.has(lower)) found.mint = v2;",
          "pattern": "rpc_helius"
        },
        {
          "line": 1018,
          "snippet": "if (typeof a === 'string' && a.length >= 32 && a.length <= 44 && !HELIUS_KNOWN_PROGRAM_IDS.has(a) && !deny.has(lower)) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 1027,
          "snippet": "for (const b of v2) { try { if (b && typeof b.mint === 'string' && b.mint.length >= 32 && b.mint.length <= 44 && !HELIUS_KNOWN_PROGRAM_IDS.has(b.mint)) { found.mint = b.mint; found.context = 'postTokenBalances'; } } catch (e) {} }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1038,
          "snippet": "if (!HELIUS_KNOWN_PROGRAM_IDS.has(cand)) { found.mint = found.mint || cand; found.context = 'log'; }",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "function isLikelyTokenByTx(parsed: any, evt: any) {",
      "hits": [
        {
          "line": 1110,
          "snippet": "// 2) explicit tokenTransfers/nativeTransfers arrays (Helius parse-history)",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "function getRecentHeliusEvents() { try { return _lastInstance ? _lastInstance.getRecentEvents() : []; } catch { return []; } }",
      "hits": [
        {
          "line": 1194,
          "snippet": "function getRecentHeliusEvents() { try { return _lastInstance ? _lastInstance.getRecentEvents() : []; } catch { return []; } }",
          "pattern": "rpc_helius"
        },
        {
          "line": 1195,
          "snippet": "export { getRecentHeliusEvents, saveLastInstance };",
          "pattern": "rpc_helius"
        },
        {
          "line": 1200,
          "snippet": "const instance = await startHeliusWebsocketListener({",
          "pattern": "rpc_helius"
        },
        {
          "line": 1211,
          "snippet": "console.log('Stopping Helius WS listener...');",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/heliusWsListener.ts",
      "func": "async function quickIsTradedByDex(mintAddr: string) {",
      "hits": [
        {
          "line": 241,
          "snippet": "const dTpl = process.env.DEXSCREENER_API_ENDPOINT_TOKEN_PAIRS || 'https://api.dexscreener.com/token-pairs/v1/solana/So11111111111111111111111111111111111111112';",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/pump/api.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 4,
          "snippet": "import axios from \"axios\";",
          "pattern": "axios"
        },
        {
          "line": 4,
          "snippet": "import axios from \"axios\";",
          "pattern": "axios"
        }
      ]
    },
    {
      "file": "src/pump/api.ts",
      "func": "export async function getCoinData(mintStr: string) {",
      "hits": [
        {
          "line": 9,
          "snippet": "const response = await axios.get(url, {",
          "pattern": "axios"
        }
      ]
    },
    {
      "file": "src/raydium/raydium.ts",
      "func": "async function initAMM(): Promise<void> {",
      "hits": [
        {
          "line": 85,
          "snippet": "const ammRes = await fetch(RAYDIUM_AMM_URL);",
          "pattern": "http_fetch"
        }
      ]
    },
    {
      "file": "src/raydium/raydium.ts",
      "func": "async function initCLMM(): Promise<void> {",
      "hits": [
        {
          "line": 128,
          "snippet": "const clmmRes = await fetch(RAYDIUM_CLMM_URL);",
          "pattern": "http_fetch"
        }
      ]
    },
    {
      "file": "src/raydium/raydium.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 390,
          "snippet": "//   const response = await fetch(",
          "pattern": "http_fetch"
        },
        {
          "line": 41,
          "snippet": "let redisClient: any;",
          "pattern": "redis"
        },
        {
          "line": 58,
          "snippet": "const _r = require(\"../services/redis\");",
          "pattern": "redis"
        },
        {
          "line": 59,
          "snippet": "redisClient = _r && (_r.default || _r);",
          "pattern": "redis"
        },
        {
          "line": 61,
          "snippet": "redisClient = null;",
          "pattern": "redis"
        },
        {
          "line": 346,
          "snippet": "await redisClient.set(key, \"added\");",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/raydium/raydium.ts",
      "func": "export async function saveTokenAccount(",
      "hits": [
        {
          "line": 173,
          "snippet": "const res = await redisClient.get(key);",
          "pattern": "redis"
        },
        {
          "line": 185,
          "snippet": "await redisClient.set(key, \"added\");",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/raydium/raydium.ts",
      "func": "async function fetchRaydiumMints(",
      "hits": [
        {
          "line": 323,
          "snippet": "const res = await redisClient.get(key);",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/screens/contract.info.screen.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 8,
          "snippet": "dexscreenerLink,",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 701,
          "snippet": ")} • ${dexscreenerLink(mint)}`;",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/screens/settings.screen.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 40,
          "snippet": "let redisClient: any;",
          "pattern": "redis"
        },
        {
          "line": 42,
          "snippet": "// redis export may be default or named",
          "pattern": "redis"
        },
        {
          "line": 43,
          "snippet": "const _r = require(\"../services/redis\");",
          "pattern": "redis"
        },
        {
          "line": 44,
          "snippet": "redisClient = _r && (_r.default || _r);",
          "pattern": "redis"
        },
        {
          "line": 46,
          "snippet": "redisClient = null;",
          "pattern": "redis"
        },
        {
          "line": 270,
          "snippet": "await redisClient.set(key, replaceId);",
          "pattern": "redis"
        },
        {
          "line": 296,
          "snippet": "await redisClient.set(key, preset_index);",
          "pattern": "redis"
        },
        {
          "line": 594,
          "snippet": "let preset_index = (await redisClient.get(key)) ?? \"0\";",
          "pattern": "redis"
        },
        {
          "line": 798,
          "snippet": "const replaceId = (await redisClient.get(key)) ?? \"0\";",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/screens/trade.screen.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 80,
          "snippet": "try { setFlagForBundleVerify = require('../services/redis.service').setFlagForBundleVerify; } catch (e) { setFlagForBundleVerify = null; }",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/tradeSources.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 2,
          "snippet": "//   await unifiedBuy(mint, amount, userSecret);",
          "pattern": "unified_trade"
        },
        {
          "line": 3,
          "snippet": "//   await unifiedSell(mint, amount, userSecret);",
          "pattern": "unified_trade"
        }
      ]
    },
    {
      "file": "src/tradeSources.ts",
      "func": "export async function unifiedBuy(mint: string, amount: number, userSecret: string): Promise<{ tx?: string; simulationError?: any; error?: string }> {",
      "hits": [
        {
          "line": 10,
          "snippet": "export async function unifiedBuy(mint: string, amount: number, userSecret: string): Promise<{ tx?: string; simulationError?: any; error?: string }> {",
          "pattern": "unified_trade"
        },
        {
          "line": 15,
          "snippet": "console.error(`[SANDBOX unifiedBuy] simulated tx=${fake} mint=${mint} amount=${amount}`);",
          "pattern": "unified_trade"
        }
      ]
    },
    {
      "file": "src/tradeSources.ts",
      "func": "export async function unifiedSell(mint: string, amount: number, userSecret: string): Promise<{ tx?: string; simulationError?: any; error?: string }> {",
      "hits": [
        {
          "line": 33,
          "snippet": "export async function unifiedSell(mint: string, amount: number, userSecret: string): Promise<{ tx?: string; simulationError?: any; error?: string }> {",
          "pattern": "unified_trade"
        },
        {
          "line": 37,
          "snippet": "console.error(`[SANDBOX unifiedSell] simulated tx=${fake} mint=${mint} amount=${amount}`);",
          "pattern": "unified_trade"
        }
      ]
    },
    {
      "file": "src/utils/enrichHelpers.ts",
      "func": "export function getHostLimiter(host: string, concurrency = 2) {",
      "hits": [
        {
          "line": 68,
          "snippet": "* Retry helper with exponential backoff for HTTP calls. Expects fn to return a Promise (usually axios request).",
          "pattern": "axios"
        }
      ]
    },
    {
      "file": "src/utils/index.ts",
      "func": "export function formatPrice(price: number) {",
      "hits": [
        {
          "line": 78,
          "snippet": "const res = await fetch(`https://public-api.birdeye.so/defi/price?address=${mint}`, options);",
          "pattern": "http_fetch"
        }
      ]
    },
    {
      "file": "src/utils/index.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 2,
          "snippet": "// import redisClient from \"../services/redis\";",
          "pattern": "redis"
        },
        {
          "line": 2,
          "snippet": "// import redisClient from \"../services/redis\";",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "src/utils/index.ts",
      "func": "export function formatKMB(val: bigint | string | number) {",
      "hits": [
        {
          "line": 53,
          "snippet": "export const dexscreenerLink = (mint: string) => {",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 54,
          "snippet": "return `<a href=\"https://dexscreener.com/solana/${mint}\">Dexscreener</a>`;",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/utils/jupiter.transaction.sender.ts",
      "func": "export async function sendJupiterTransaction({ mint, amount, userSecret, side }: { mint: string; amount: number; userSecret: string; side: \"buy\" | \"sell\" }) {",
      "hits": [
        {
          "line": 22,
          "snippet": "const quoteRes = await fetch(quoteUrl);",
          "pattern": "http_fetch"
        },
        {
          "line": 34,
          "snippet": "const swapRes = await fetch(\"https://quote-api.jup.ag/v6/swap\", {",
          "pattern": "http_fetch"
        }
      ]
    },
    {
      "file": "src/utils/portfolioCopyMonitor.ts",
      "func": "async function fetchRecentTrades(wallet: string): Promise<Array<{token: string; amount: number; type: 'buy'|'sell'; tx: string;}>> {",
      "hits": [
        {
          "line": 32,
          "snippet": "const res = await fetch(`https://public-api.birdeye.so/public/wallet/txs?address=${wallet}&limit=5`);",
          "pattern": "http_fetch"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function fetchDexScreenerPairsForSolanaTokens(tokenAddresses: string[]): Promise<any[]> {",
      "hits": [
        {
          "line": 380,
          "snippet": "* @param chainId Chain to fetch (default: 'solana')",
          "pattern": "http_fetch"
        },
        {
          "line": 373,
          "snippet": "export async function fetchDexScreenerPairsForSolanaTokens(tokenAddresses: string[]): Promise<any[]> {",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 374,
          "snippet": "// DexScreener pairs disabled. Listener-only mode: return empty list.",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 379,
          "snippet": "* Fetch Solana tokens (or any chain) from DexScreener with optional params.",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 86,
          "snippet": "import axios from 'axios';",
          "pattern": "axios"
        },
        {
          "line": 86,
          "snippet": "import axios from 'axios';",
          "pattern": "axios"
        },
        {
          "line": 92,
          "snippet": "HELIUS_RPC_URL,",
          "pattern": "rpc_helius"
        },
        {
          "line": 93,
          "snippet": "HELIUS_PARSE_HISTORY_URL,",
          "pattern": "rpc_helius"
        },
        {
          "line": 94,
          "snippet": "HELIUS_API_KEY,",
          "pattern": "rpc_helius"
        },
        {
          "line": 95,
          "snippet": "HELIUS_CACHE_TTL_MS,",
          "pattern": "rpc_helius"
        },
        {
          "line": 96,
          "snippet": "HELIUS_RETRY_MAX_ATTEMPTS,",
          "pattern": "rpc_helius"
        },
        {
          "line": 97,
          "snippet": "HELIUS_RETRY_BASE_MS,",
          "pattern": "rpc_helius"
        },
        {
          "line": 98,
          "snippet": "HELIUS_RETRY_JITTER_MS,",
          "pattern": "rpc_helius"
        },
        {
          "line": 99,
          "snippet": "HELIUS_FALLBACK_ENABLED,",
          "pattern": "rpc_helius"
        },
        {
          "line": 100,
          "snippet": "HELIUS_SIG_LIMIT,",
          "pattern": "rpc_helius"
        },
        {
          "line": 101,
          "snippet": "HELIUS_RPC_CONCURRENCY,",
          "pattern": "rpc_helius"
        },
        {
          "line": 102,
          "snippet": "HELIUS_BATCH_SIZE,",
          "pattern": "rpc_helius"
        },
        {
          "line": 103,
          "snippet": "HELIUS_BATCH_DELAY_MS,",
          "pattern": "rpc_helius"
        },
        {
          "line": 104,
          "snippet": "HELIUS_ENRICH_LIMIT,",
          "pattern": "rpc_helius"
        },
        {
          "line": 109,
          "snippet": "HELIUS_USE_WEBSOCKET,",
          "pattern": "rpc_helius"
        },
        {
          "line": 110,
          "snippet": "HELIUS_WS_URL_RAW,",
          "pattern": "rpc_helius"
        },
        {
          "line": 443,
          "snippet": "// ===== Enrichment helpers (Helius primary, RPC fallback) =====",
          "pattern": "rpc_helius"
        },
        {
          "line": 444,
          "snippet": "const heliusTimestampCache: Record<string, { ts: number | null; fetchedAt: number }> = {};",
          "pattern": "rpc_helius"
        },
        {
          "line": 446,
          "snippet": "const heliusHostState: Record<string, { failureCount: number; cooldownUntil: number }> = {};",
          "pattern": "rpc_helius"
        },
        {
          "line": 448,
          "snippet": "heliusCalls: number; heliusFailures: number; heliusTotalMs: number;",
          "pattern": "rpc_helius"
        },
        {
          "line": 448,
          "snippet": "heliusCalls: number; heliusFailures: number; heliusTotalMs: number;",
          "pattern": "rpc_helius"
        },
        {
          "line": 448,
          "snippet": "heliusCalls: number; heliusFailures: number; heliusTotalMs: number;",
          "pattern": "rpc_helius"
        },
        {
          "line": 452,
          "snippet": "heliusCalls: 0, heliusFailures: 0, heliusTotalMs: 0,",
          "pattern": "rpc_helius"
        },
        {
          "line": 452,
          "snippet": "heliusCalls: 0, heliusFailures: 0, heliusTotalMs: 0,",
          "pattern": "rpc_helius"
        },
        {
          "line": 452,
          "snippet": "heliusCalls: 0, heliusFailures: 0, heliusTotalMs: 0,",
          "pattern": "rpc_helius"
        },
        {
          "line": 597,
          "snippet": "if (!status || status >= 500 || status === 429) enrichmentMetrics.heliusFailures++;",
          "pattern": "rpc_helius"
        },
        {
          "line": 603,
          "snippet": "const state = heliusHostState[hostKey] || { failureCount: 0, cooldownUntil: 0 };",
          "pattern": "rpc_helius"
        },
        {
          "line": 608,
          "snippet": "heliusHostState[hostKey] = state;",
          "pattern": "rpc_helius"
        },
        {
          "line": 611,
          "snippet": "console.warn(`[Helius] ${hostKey} responded 429 — entering cooldown ~${Math.round(cooldown/1000)}s`);",
          "pattern": "rpc_helius"
        },
        {
          "line": 640,
          "snippet": "console.error(`[Helius] HTTP failure for ${host} after retries (status=${status}) headers=[${headersSnippet}] data=${dataSnippet} message=${String(lastErr?.message || lastErr)}`);",
          "pattern": "rpc_helius"
        },
        {
          "line": 642,
          "snippet": "console.error('[Helius] HTTP failure after retries');",
          "pattern": "rpc_helius"
        },
        {
          "line": 648,
          "snippet": "// Optional: try Helius WebSocket RPC when configured (preferred for live parsed streams)",
          "pattern": "rpc_helius"
        },
        {
          "line": 650,
          "snippet": "if (false && HELIUS_USE_WEBSOCKET && HELIUS_WS_URL_RAW) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 650,
          "snippet": "if (false && HELIUS_USE_WEBSOCKET && HELIUS_WS_URL_RAW) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 654,
          "snippet": "const wsUrl = HELIUS_WS_URL_RAW as string;",
          "pattern": "rpc_helius"
        },
        {
          "line": 662,
          "snippet": "const sigLimit = Number(HELIUS_SIG_LIMIT || 20);",
          "pattern": "rpc_helius"
        },
        {
          "line": 714,
          "snippet": "if (earliestMs) { heliusTimestampCache[address] = { ts: earliestMs, fetchedAt: Date.now() }; try { setCachedFirstTx(address, earliestMs); } catch (e) {} return earliestMs; }",
          "pattern": "rpc_helius"
        },
        {
          "line": 720,
          "snippet": "try { console.warn(`[Helius] WS attempt failed for ${address}: ${e?.message || e}`); } catch(_) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 723,
          "snippet": "// 1) Try Helius RPC endpoint via solana web3 (best for paid keys)",
          "pattern": "rpc_helius"
        },
        {
          "line": 724,
          "snippet": "if (heliusRpc) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 727,
          "snippet": "const conn = new Connection(heliusRpc, { commitment: 'confirmed' } as any);",
          "pattern": "rpc_helius"
        },
        {
          "line": 730,
          "snippet": "enrichmentMetrics.heliusCalls++;",
          "pattern": "rpc_helius"
        },
        {
          "line": 732,
          "snippet": "const collectSignaturesFull = async (maxCollect = Number(process.env.HELIUS_RPC_SIG_PAGE_MAX || 2000)) => {",
          "pattern": "rpc_helius"
        },
        {
          "line": 735,
          "snippet": "const limit = Number(HELIUS_SIG_LIMIT || 1000);",
          "pattern": "rpc_helius"
        },
        {
          "line": 752,
          "snippet": "const sigs = await collectSignaturesFull(Number(process.env.HELIUS_RPC_SIG_PAGE_MAX || 2000));",
          "pattern": "rpc_helius"
        },
        {
          "line": 754,
          "snippet": "enrichmentMetrics.heliusTotalMs += (Date.now() - start);",
          "pattern": "rpc_helius"
        },
        {
          "line": 755,
          "snippet": "// no signatures found via Helius RPC",
          "pattern": "rpc_helius"
        },
        {
          "line": 758,
          "snippet": "const concurrency = Math.max(1, Number(HELIUS_RPC_CONCURRENCY || 2));",
          "pattern": "rpc_helius"
        },
        {
          "line": 770,
          "snippet": "enrichmentMetrics.heliusTotalMs += (Date.now() - start);",
          "pattern": "rpc_helius"
        },
        {
          "line": 771,
          "snippet": "heliusTimestampCache[address] = { ts: earliestMs, fetchedAt: Date.now() };",
          "pattern": "rpc_helius"
        },
        {
          "line": 775,
          "snippet": "try { console.warn(`[Helius] RPC endpoint attempt failed for ${address}: ${err?.message || err}`); } catch(_) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 779,
          "snippet": "// 2) Fall back to Helius parse/history HTTP endpoints (if configured)",
          "pattern": "rpc_helius"
        },
        {
          "line": 782,
          "snippet": "const r = await heliusHttpGetWithRetries(url);",
          "pattern": "rpc_helius"
        },
        {
          "line": 785,
          "snippet": "heliusTimestampCache[address] = { ts: null, fetchedAt: Date.now() };",
          "pattern": "rpc_helius"
        },
        {
          "line": 797,
          "snippet": "heliusTimestampCache[address] = { ts: resultMs, fetchedAt: Date.now() };",
          "pattern": "rpc_helius"
        },
        {
          "line": 805,
          "snippet": "enrichmentMetrics.heliusFailures++;",
          "pattern": "rpc_helius"
        },
        {
          "line": 806,
          "snippet": "try { console.error(`[Helius] getFirstTxTimestampFromHelius failed for ${address}: ${e?.message || e}`); } catch(_) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 806,
          "snippet": "try { console.error(`[Helius] getFirstTxTimestampFromHelius failed for ${address}: ${e?.message || e}`); } catch(_) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 807,
          "snippet": "if (HELIUS_FALLBACK_ENABLED) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 855,
          "snippet": "export { getFirstTxTimestampFromHelius, getFirstTxTimestampFromRpc };",
          "pattern": "rpc_helius"
        },
        {
          "line": 437,
          "snippet": "console.error('[fetchDexScreenerTokens] listener fetch failed:', e?.message || e);",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 937,
          "snippet": "* Uses DexScreener / pair timestamps (token.poolOpenTimeMs, pairCreatedAt),",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 1365,
          "snippet": "msg += `\\n${memecoinEmoji} <b>Solana Memecoin Community</b> | ${solEmoji} <b>Powered by DexScreener</b>\\n`;",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 1387,
          "snippet": "msgMd += `\\n🚀 Solana Memecoin Community | 🟣 Powered by DexScreener\\n`;",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 1551,
          "snippet": "'No tokens currently match your strategy.\\n\\nYour strategy filters may be too strict for the available data from DexScreener.\\n\\nTry lowering requirements like liquidity, market cap, volume, age, or holders, then try again.',",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "async function heliusHttpGetWithRetries(url: string, maxAttempts = Number(HELIUS_RETRY_MAX_ATTEMPTS || 1)) {",
      "hits": [
        {
          "line": 554,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 554,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 586,
          "snippet": "const r = await axios.get(url, { timeout: 20000, headers });",
          "pattern": "axios"
        },
        {
          "line": 553,
          "snippet": "async function heliusHttpGetWithRetries(url: string, maxAttempts = Number(HELIUS_RETRY_MAX_ATTEMPTS || 1)) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 553,
          "snippet": "async function heliusHttpGetWithRetries(url: string, maxAttempts = Number(HELIUS_RETRY_MAX_ATTEMPTS || 1)) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 556,
          "snippet": "const baseMs = Number(HELIUS_RETRY_BASE_MS || 500);",
          "pattern": "rpc_helius"
        },
        {
          "line": 557,
          "snippet": "const jitterMs = Number(HELIUS_RETRY_JITTER_MS || 300);",
          "pattern": "rpc_helius"
        },
        {
          "line": 562,
          "snippet": "const state = heliusHostState[hostKey];",
          "pattern": "rpc_helius"
        },
        {
          "line": 566,
          "snippet": "err.code = 'HELIUS_HOST_COOLDOWN';",
          "pattern": "rpc_helius"
        },
        {
          "line": 574,
          "snippet": "const st = heliusHostState[hostKeyTmp];",
          "pattern": "rpc_helius"
        },
        {
          "line": 583,
          "snippet": "enrichmentMetrics.heliusCalls++;",
          "pattern": "rpc_helius"
        },
        {
          "line": 585,
          "snippet": "try { const { getHeliusApiKey, maskKey } = await import('../config'); const _hk = getHeliusApiKey(); if (_hk) { headers['x-api-key'] = _hk; try { console.log(`[Helius] using key=${maskKey(_hk)}`); } catch (e) {} } } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 585,
          "snippet": "try { const { getHeliusApiKey, maskKey } = await import('../config'); const _hk = getHeliusApiKey(); if (_hk) { headers['x-api-key'] = _hk; try { console.log(`[Helius] using key=${maskKey(_hk)}`); } catch (e) {} } } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 585,
          "snippet": "try { const { getHeliusApiKey, maskKey } = await import('../config'); const _hk = getHeliusApiKey(); if (_hk) { headers['x-api-key'] = _hk; try { console.log(`[Helius] using key=${maskKey(_hk)}`); } catch (e) {} } } catch (e) {}",
          "pattern": "rpc_helius"
        },
        {
          "line": 587,
          "snippet": "enrichmentMetrics.heliusTotalMs += (Date.now() - start);",
          "pattern": "rpc_helius"
        },
        {
          "line": 589,
          "snippet": "if (hostKey && heliusHostState[hostKey]) {",
          "pattern": "rpc_helius"
        },
        {
          "line": 590,
          "snippet": "heliusHostState[hostKey].failureCount = 0;",
          "pattern": "rpc_helius"
        },
        {
          "line": 591,
          "snippet": "heliusHostState[hostKey].cooldownUntil = 0;",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "async function getFirstTxTimestampFromSolscan(address: string): Promise<number | null> {",
      "hits": [
        {
          "line": 821,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 821,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 826,
          "snippet": "const r = await axios.get(url, { timeout: 8000, headers });",
          "pattern": "axios"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function finalJupiterCheck(mint: string, buyAmountSol: number, opts?: { minJupiterUsd?: number; requireRoute?: boolean; timeoutMs?: number }) {",
      "hits": [
        {
          "line": 1743,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 1743,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 1744,
          "snippet": "const cg = await axios.get('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd', { timeout: 2000 });",
          "pattern": "axios"
        },
        {
          "line": 1757,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 1757,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 1760,
          "snippet": "const res = await axios.get(url, { timeout, headers });",
          "pattern": "axios"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function fetchDexScreenerTokens(chainId: string = 'solana', extraParams?: Record<string, string>): Promise<any[]> {",
      "hits": [
        {
          "line": 389,
          "snippet": "if (!seq || typeof seq.collectFreshMints !== 'function') return [];",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 402,
          "snippet": "const items: any[] = await seq.collectFreshMints({ maxCollect, timeoutMs, maxAgeSec, strictOverride, onlyPrintExplicit: true }).catch(() => []);",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 383,
          "snippet": "export async function fetchDexScreenerTokens(chainId: string = 'solana', extraParams?: Record<string, string>): Promise<any[]> {",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function enrichTokenTimestamps(tokens: any[], opts?: { batchSize?: number; delayMs?: number }) {",
      "hits": [
        {
          "line": 1014,
          "snippet": "export async function enrichTokenTimestamps(tokens: any[], opts?: { batchSize?: number; delayMs?: number }) {",
          "pattern": "enrich"
        },
        {
          "line": 1021,
          "snippet": "console.log('[ENRICH] enrichTokenTimestamps skipped due to collectorGuard (FORCE_ENRICH not set)');",
          "pattern": "enrich"
        },
        {
          "line": 1015,
          "snippet": "const batchSize = opts?.batchSize ?? Number(HELIUS_BATCH_SIZE || 4);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1016,
          "snippet": "const delayMs = opts?.delayMs ?? Number(HELIUS_BATCH_DELAY_MS || 400);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1017,
          "snippet": "const enrichLimit = Number(HELIUS_ENRICH_LIMIT || 8);",
          "pattern": "rpc_helius"
        },
        {
          "line": 1048,
          "snippet": "try { ts = await getFirstTxTimestampFromHelius(addr); } catch (e) { ts = null; }",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export function getEnrichmentMetrics() {",
      "hits": [
        {
          "line": 1094,
          "snippet": "* officialEnrich: perform an authoritative enrichment for a single token object.",
          "pattern": "enrich"
        },
        {
          "line": 1095,
          "snippet": "* - runs the existing on-chain + solscan enrichment paths (via enrichTokenTimestamps)",
          "pattern": "enrich"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function officialEnrich(token: any, opts?: { amountUsd?: number; timeoutMs?: number }) {",
      "hits": [
        {
          "line": 1099,
          "snippet": "export async function officialEnrich(token: any, opts?: { amountUsd?: number; timeoutMs?: number }) {",
          "pattern": "enrich"
        },
        {
          "line": 1118,
          "snippet": "try { await enrichTokenTimestamps([token], { batchSize: 1, delayMs: 0 }); } catch (e) {}",
          "pattern": "enrich"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "function progressBar(percent: number, size = 10, fill = '█', empty = '░') {",
      "hits": [
        {
          "line": 1493,
          "snippet": "// Notify users with matching tokens (always uses autoFilterTokens)",
          "pattern": "enrich"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function notifyUsers(bot: any, users: Record<string, any>, tokens: any[]) {",
      "hits": [
        {
          "line": 1509,
          "snippet": "const filteredVerbose = autoFilterTokensVerbose(tokens, strategy);",
          "pattern": "enrich"
        },
        {
          "line": 1497,
          "snippet": "// external quick-sources (DexScreener, etc.) from being sent to users when the",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export function autoFilterTokensVerbose(tokens: any[], strategy: Record<string, any>): { passed: any[]; rejected: Array<{ token: any; reasons: string[] }> } {",
      "hits": [
        {
          "line": 1560,
          "snippet": "export function autoFilterTokensVerbose(tokens: any[], strategy: Record<string, any>): { passed: any[]; rejected: Array<{ token: any; reasons: string[] }> } {",
          "pattern": "enrich"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export function autoFilterTokens(tokens: any[], strategy: Record<string, any>): any[] {",
      "hits": [
        {
          "line": 1641,
          "snippet": "export function autoFilterTokens(tokens: any[], strategy: Record<string, any>): any[] {",
          "pattern": "enrich"
        },
        {
          "line": 1642,
          "snippet": "try { return autoFilterTokensVerbose(tokens, strategy).passed; } catch (e) { return tokens; }",
          "pattern": "enrich"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "async function getFirstTxTimestampFromRpc(address: string): Promise<number | null> {",
      "hits": [
        {
          "line": 469,
          "snippet": "const rpcUrl = HELIUS_RPC_URL || process.env.MAINNET_RPC;",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "async function getFirstTxTimestampFromHelius(address: string): Promise<number | null> {",
      "hits": [
        {
          "line": 536,
          "snippet": "async function getFirstTxTimestampFromHelius(address: string): Promise<number | null> {",
          "pattern": "rpc_helius"
        },
        {
          "line": 537,
          "snippet": "// Avoid Helius HTTP/RPC calls in listener-only mode to keep active flows local.",
          "pattern": "rpc_helius"
        },
        {
          "line": 539,
          "snippet": "// Prefer Helius RPC (if provided) which is typically higher-rate for paid keys.",
          "pattern": "rpc_helius"
        },
        {
          "line": 540,
          "snippet": "const heliusRpc = HELIUS_RPC_URL || process.env.MAINNET_RPC;",
          "pattern": "rpc_helius"
        },
        {
          "line": 540,
          "snippet": "const heliusRpc = HELIUS_RPC_URL || process.env.MAINNET_RPC;",
          "pattern": "rpc_helius"
        },
        {
          "line": 541,
          "snippet": "const apiUrlTemplate = HELIUS_PARSE_HISTORY_URL || '';",
          "pattern": "rpc_helius"
        },
        {
          "line": 548,
          "snippet": "const cached = heliusTimestampCache[address];",
          "pattern": "rpc_helius"
        },
        {
          "line": 549,
          "snippet": "const ttl = Number(HELIUS_CACHE_TTL_MS || 24 * 60 * 60 * 1000);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function checkOnChainActivity(address: string): Promise<{ firstTxMs: number | null; found: boolean }> {",
      "hits": [
        {
          "line": 861,
          "snippet": "// Prefer Helius / RPC path since they tend to return parsed transactions or block times",
          "pattern": "rpc_helius"
        },
        {
          "line": 864,
          "snippet": "if (!LISTENER_ONLY_MODE) ts = await getFirstTxTimestampFromHelius(address);",
          "pattern": "rpc_helius"
        },
        {
          "line": 868,
          "snippet": "// If Helius did not yield a result, fall back to RPC (skip Solscan per config)",
          "pattern": "rpc_helius"
        },
        {
          "line": 890,
          "snippet": "* - Tries Helius -> Solscan -> RPC fallbacks (configurable via environment flags in config.ts).",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function getFirstOnchainTimestamp(address: string, opts?: { timeoutMs?: number; prefer?: ('hel'|'solscan'|'rpc')[] }): Promise<{ ts: number | null; source?: string; cached?: boolean }> {",
      "hits": [
        {
          "line": 904,
          "snippet": "// Prefer Helius first, then RPC. Solscan fallback disabled per operator request.",
          "pattern": "rpc_helius"
        },
        {
          "line": 913,
          "snippet": "const ts = await withTimeout(getFirstTxTimestampFromHelius(address), timeoutMs, 'firsttx-helius');",
          "pattern": "rpc_helius"
        },
        {
          "line": 913,
          "snippet": "const ts = await withTimeout(getFirstTxTimestampFromHelius(address), timeoutMs, 'firsttx-helius');",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "function runNext() {",
      "hits": [
        {
          "line": 1702,
          "snippet": "const ONCHAIN_CONCURRENCY = Number(process.env.ONCHAIN_CONCURRENCY || process.env.HELIUS_ONCHAIN_CONCURRENCY || 2);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export function normalizeTokenForDisplay(raw: any): { mint?: string; tokenAddress?: string; address?: string; [k:string]: any } {",
      "hits": [
        {
          "line": 333,
          "snippet": "// ========== Fetch token data from CoinGecko and DexScreener ==========",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function fetchSolanaFromCoinGecko(): Promise<any> {",
      "hits": [
        {
          "line": 358,
          "snippet": "// ========== DexScreener API Integration ==========",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 361,
          "snippet": "* Fetch token profiles from DexScreener API.",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "export async function fetchDexScreenerProfiles(chainId?: string, extraParams?: Record<string, string>): Promise<any[]> {",
      "hits": [
        {
          "line": 368,
          "snippet": "export async function fetchDexScreenerProfiles(chainId?: string, extraParams?: Record<string, string>): Promise<any[]> {",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 369,
          "snippet": "// DexScreener profiles disabled. Listener-only mode: return empty list.",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/utils/tokenUtils.ts",
      "func": "function buildInlineKeyboard(token: any, botUsername: string, pairAddress: string, userId?: string) {",
      "hits": [
        {
          "line": 1168,
          "snippet": "// Only add a DexScreener/extern link when the token is explicit AND token.url is provided by the collector/enrichment.",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 1170,
          "snippet": "row1.push({ text: `${dexEmoji} DexScreener`, url: token.url });",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "src/wallet.ts",
      "func": "export function exportSecretKey(keypair: any): string {",
      "hits": [
        {
          "line": 72,
          "snippet": "import { MAINNET_RPC, HELIUS_RPC_URL } from './config';",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "src/wallet.ts",
      "func": "export function getConnection() {",
      "hits": [
        {
          "line": 76,
          "snippet": "const rpcUrl = HELIUS_RPC_URL || MAINNET_RPC || process.env.RPC_URL || clusterApiUrl(network);",
          "pattern": "rpc_helius"
        }
      ]
    },
    {
      "file": "telegramBot.ts",
      "func": "async function getTokensForUser(userId: string, strategy: Record<string, any> | undefined) {",
      "hits": [
        {
          "line": 248,
          "snippet": "if (!seq || typeof seq.collectFreshMints !== 'function') return [];",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 253,
          "snippet": "let items = await seq.collectFreshMints({ maxCollect, strictOverride, onlyPrintExplicit: true }).catch((e: any) => { traceFlow('collector:collectFreshMints:error', { err: String(e) }); return []; });",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 253,
          "snippet": "let items = await seq.collectFreshMints({ maxCollect, strictOverride, onlyPrintExplicit: true }).catch((e: any) => { traceFlow('collector:collectFreshMints:error', { err: String(e) }); return []; });",
          "pattern": "collector_collectFreshMints"
        }
      ]
    },
    {
      "file": "telegramBot.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 460,
          "snippet": "if (!seq || typeof seq.collectFreshMintsPerUser !== 'function') {",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 467,
          "snippet": "const collected = await seq.collectFreshMintsPerUser(usersObj, { maxCollect, timeoutMs: Number(process.env.COLLECT_TIMEOUT_MS || 20000), strictOverride, ageOnly: ageOnlyMode, onlyPrintExplicit: true }).catch(() => ({}));",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1119,
          "snippet": "if(seq && typeof seq.collectFreshMintsPerUser === 'function'){",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1125,
          "snippet": "const collected = await seq.collectFreshMintsPerUser(usersObj, { maxCollect: Math.max(1, Number(user.strategy?.maxTrades || 3)), timeoutMs: Number(process.env.COLLECT_TIMEOUT_MS || 20000), strictOverride, ageOnly: true, onlyPrintExplicit: true }).catch(()=>({}));",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1214,
          "snippet": "if(seq && typeof seq.collectFreshMints === 'function'){",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1231,
          "snippet": "const addrs = await seq.collectFreshMints({ maxCollect, maxAgeSec, strictOverride, onlyPrintExplicit: true }).catch(()=>[]);",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1257,
          "snippet": "if(seq && typeof seq.collectFreshMints === 'function'){",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 1270,
          "snippet": "const addrs = await seq.collectFreshMints({ maxCollect, maxAgeSec, strictOverride, onlyPrintExplicit: true }).catch(()=>[]);",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 56,
          "snippet": "const HELIUS_BATCH_SIZE = Number(process.env.HELIUS_BATCH_SIZE ?? 8);",
          "pattern": "rpc_helius"
        },
        {
          "line": 56,
          "snippet": "const HELIUS_BATCH_SIZE = Number(process.env.HELIUS_BATCH_SIZE ?? 8);",
          "pattern": "rpc_helius"
        },
        {
          "line": 57,
          "snippet": "const HELIUS_BATCH_DELAY_MS = Number(process.env.HELIUS_BATCH_DELAY_MS ?? 250);",
          "pattern": "rpc_helius"
        },
        {
          "line": 57,
          "snippet": "const HELIUS_BATCH_DELAY_MS = Number(process.env.HELIUS_BATCH_DELAY_MS ?? 250);",
          "pattern": "rpc_helius"
        },
        {
          "line": 58,
          "snippet": "const HELIUS_ENRICH_LIMIT = Number(process.env.HELIUS_ENRICH_LIMIT ?? 25);",
          "pattern": "rpc_helius"
        },
        {
          "line": 58,
          "snippet": "const HELIUS_ENRICH_LIMIT = Number(process.env.HELIUS_ENRICH_LIMIT ?? 25);",
          "pattern": "rpc_helius"
        },
        {
          "line": 80,
          "snippet": "let _redisSnapshotCache: { ts: number, allowed: Set<string> } | null = null;",
          "pattern": "redis"
        },
        {
          "line": 148,
          "snippet": "if(!_redisSnapshotCache || (Date.now() - _redisSnapshotCache.ts) > cacheTtlMs){",
          "pattern": "redis"
        },
        {
          "line": 148,
          "snippet": "if(!_redisSnapshotCache || (Date.now() - _redisSnapshotCache.ts) > cacheTtlMs){",
          "pattern": "redis"
        },
        {
          "line": 149,
          "snippet": "const redisAllowed = await _getAllowedFromRedis().catch(()=>new Set());",
          "pattern": "redis"
        },
        {
          "line": 151,
          "snippet": "const redisAllowedStr = new Set<string>();",
          "pattern": "redis"
        },
        {
          "line": 152,
          "snippet": "try{ for(const v of Array.from(redisAllowed || [] as any)) if(v) redisAllowedStr.add(String(v)); }catch(e){}",
          "pattern": "redis"
        },
        {
          "line": 152,
          "snippet": "try{ for(const v of Array.from(redisAllowed || [] as any)) if(v) redisAllowedStr.add(String(v)); }catch(e){}",
          "pattern": "redis"
        },
        {
          "line": 153,
          "snippet": "_redisSnapshotCache = { ts: Date.now(), allowed: redisAllowedStr };",
          "pattern": "redis"
        },
        {
          "line": 153,
          "snippet": "_redisSnapshotCache = { ts: Date.now(), allowed: redisAllowedStr };",
          "pattern": "redis"
        },
        {
          "line": 155,
          "snippet": "if(_redisSnapshotCache && _redisSnapshotCache.allowed && _redisSnapshotCache.allowed.size>0){",
          "pattern": "redis"
        },
        {
          "line": 155,
          "snippet": "if(_redisSnapshotCache && _redisSnapshotCache.allowed && _redisSnapshotCache.allowed.size>0){",
          "pattern": "redis"
        },
        {
          "line": 155,
          "snippet": "if(_redisSnapshotCache && _redisSnapshotCache.allowed && _redisSnapshotCache.allowed.size>0){",
          "pattern": "redis"
        },
        {
          "line": 156,
          "snippet": "for(const a of _redisSnapshotCache.allowed) allowed.add(a);",
          "pattern": "redis"
        },
        {
          "line": 160,
          "snippet": "// If collector+redis snapshot is empty/unavailable then deny any outgoing message containing addresses",
          "pattern": "redis"
        },
        {
          "line": 879,
          "snippet": "// Disable background file/redis polling notification pump. Instead listen to",
          "pattern": "redis"
        },
        {
          "line": 1066,
          "snippet": "// Note: background disk/redis notification pump disabled — using in-process notifier for immediate delivery.",
          "pattern": "redis"
        },
        {
          "line": 8,
          "snippet": "import { unifiedBuy, unifiedSell } from './src/tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 8,
          "snippet": "import { unifiedBuy, unifiedSell } from './src/tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 1112,
          "snippet": "// If the listener module exists but returns no fresh mints, DO NOT fallback to DexScreener",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 880,
          "snippet": "// in-process notifier events emitted by the listener and deliver messages",
          "pattern": "ws_listener"
        },
        {
          "line": 887,
          "snippet": "// require the exported notifier from the listener script (if it's loaded in-process)",
          "pattern": "ws_listener"
        },
        {
          "line": 889,
          "snippet": "try{ const seqMod = require('./scripts/sequential_10s_per_program.js'); listenerNotifier = seqMod && seqMod.notifier ? seqMod.notifier : null; }catch(e){}",
          "pattern": "ws_listener"
        },
        {
          "line": 889,
          "snippet": "try{ const seqMod = require('./scripts/sequential_10s_per_program.js'); listenerNotifier = seqMod && seqMod.notifier ? seqMod.notifier : null; }catch(e){}",
          "pattern": "ws_listener"
        },
        {
          "line": 890,
          "snippet": "// register handler on the exported notifier if present",
          "pattern": "ws_listener"
        },
        {
          "line": 895,
          "snippet": "traceFlow('notifier:event_received', { user: userEvent && userEvent.user, program: userEvent && userEvent.program, tokens: Array.isArray(userEvent.tokens)?userEvent.tokens.length:0 });",
          "pattern": "ws_listener"
        },
        {
          "line": 908,
          "snippet": "traceFlow('notifier:after_prepare_tokens', { user: uid, payloadTokens: tokenObjs.length });",
          "pattern": "ws_listener"
        },
        {
          "line": 943,
          "snippet": "traceFlow('notifier:guard_result', { user: uid, sent: Boolean(sent) });",
          "pattern": "ws_listener"
        },
        {
          "line": 1066,
          "snippet": "// Note: background disk/redis notification pump disabled — using in-process notifier for immediate delivery.",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "telegramBot.ts",
      "func": "async function _getAllowedFromRedis(): Promise<Set<string>>{",
      "hits": [
        {
          "line": 85,
          "snippet": "const { createClient } = require('redis');",
          "pattern": "redis"
        },
        {
          "line": 86,
          "snippet": "const rc = createClient({ url: REDIS_URL });",
          "pattern": "redis"
        },
        {
          "line": 90,
          "snippet": "const raw = await rc.get(key).catch(()=>null);",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "telegramBot.ts",
      "func": "(async function startRedisConsumer(){",
      "hits": [
        {
          "line": 975,
          "snippet": "const { createClient } = require('redis');",
          "pattern": "redis"
        },
        {
          "line": 976,
          "snippet": "const rc = createClient({ url: REDIS_URL });",
          "pattern": "redis"
        },
        {
          "line": 986,
          "snippet": "const res = await rc.rPop(key).catch(()=>null);",
          "pattern": "redis"
        },
        {
          "line": 995,
          "snippet": "}catch(e){ console.error('[redisNotifConsumer] failed', e && e.message || e); }",
          "pattern": "redis"
        }
      ]
    },
    {
      "file": "tokenFilterDemo.js",
      "func": "<top>",
      "hits": [
        {
          "line": 6,
          "snippet": "const nf = require('node-fetch');",
          "pattern": "node_fetch_require"
        },
        {
          "line": 1,
          "snippet": "// Dynamic, visual, English-only token filter demo for DexScreener Boosts API",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 10,
          "snippet": "const ENDPOINT = process.env.DEXSCREENER_API_ENDPOINT || 'https://api.dexscreener.com/token/latest/v1';",
          "pattern": "dextools/dexscreener"
        }
      ]
    },
    {
      "file": "wsListener.ts",
      "func": "<top>",
      "hits": [
        {
          "line": 142,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 142,
          "snippet": "const axios = (await import('axios')).default;",
          "pattern": "axios"
        },
        {
          "line": 143,
          "snippet": "const r = await axios.get(url, { timeout: 5000 });",
          "pattern": "axios"
        },
        {
          "line": 7,
          "snippet": "import { unifiedBuy, unifiedSell } from './src/tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 7,
          "snippet": "import { unifiedBuy, unifiedSell } from './src/tradeSources';",
          "pattern": "unified_trade"
        },
        {
          "line": 163,
          "snippet": "const result = await unifiedBuy(addr, buyAmount, user.secret);",
          "pattern": "unified_trade"
        },
        {
          "line": 196,
          "snippet": "const sellResult = await unifiedSell(addr, buyAmount, user.secret);",
          "pattern": "unified_trade"
        },
        {
          "line": 216,
          "snippet": "const sellResult = await unifiedSell(addr, buyAmount, user.secret);",
          "pattern": "unified_trade"
        },
        {
          "line": 5,
          "snippet": "import { fetchDexScreenerTokens } from './src/utils/tokenUtils';",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 187,
          "snippet": "const freshTokens = await fetchDexScreenerTokens('solana', { limit: '100' });",
          "pattern": "dextools/dexscreener"
        },
        {
          "line": 255,
          "snippet": "console.error('Error processing token in wsListener loop:', e);",
          "pattern": "ws_listener"
        }
      ]
    },
    {
      "file": "wsListener.ts",
      "func": "async function pollAndNotify() {",
      "hits": [
        {
          "line": 69,
          "snippet": "if (seq && typeof seq.collectFreshMintsPerUser === 'function') {",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 72,
          "snippet": "const collected = await seq.collectFreshMintsPerUser(usersObj, { maxCollect: collectorBatchLimit, timeoutMs: Number(process.env.COLLECT_TIMEOUT_MS || 20000), strictOverride: undefined, ageOnly: true, onlyPrintExplicit: true }).catch(() => ({}));",
          "pattern": "collector_collectFreshMints"
        },
        {
          "line": 55,
          "snippet": "// Import hash and sent-tokens helpers from fastTokenFetcher",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 56,
          "snippet": "const { hashTokenAddress, readSentHashes, appendSentHash } = await import('./src/fastTokenFetcher');",
          "pattern": "fastTokenFetcher"
        },
        {
          "line": 41,
          "snippet": "const tokens = await fetchDexScreenerTokens('solana', { limit: '100' });",
          "pattern": "dextools/dexscreener"
        }
      ]
    }
  ]
}
